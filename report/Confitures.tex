\documentclass[12pt,a4paper]{article}

%########################### Preferences #################################


% ******** vmargin settings *********
\usepackage{vmargin} %This give you full control over the used page arae, it maybe not the idea od Latex to do so, but I wanted to reduce to amount of white space on the page
\setpapersize{A4}
\setmargins{3cm}%			%linker Rand, left edge
					 {1.5cm}%     %oberer Rand, top edge
           {14.7cm}%		%Textbreite, text width
           {23.42cm}%   %Texthoehe, text hight
           {14pt}%			%Kopfzeilenhöhe, header hight
           {1cm}%   	  %Kopfzeilenabstand, header distance
           {0pt}%				%Fußzeilenhoehe footer hight
           {2cm}%    	  %Fusszeilenabstand, footer distance

% ********* Font definiton ************
\usepackage{t1enc} % as usual
\usepackage[utf8]{inputenc} % as usual
\usepackage[french]{babel}
\usepackage{makeidx}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{amssymb}
\usepackage[shortlabels]{enumitem} 
\usepackage{siunitx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[T1]{fontenc}
\usepackage[titletoc]{appendix}

% ********* Graphics definition *******
\usepackage[pdftex]{graphicx} % required to import graphic files
\usepackage{eso-pic} % these two are required to add the little picture on top of every page
\usepackage{everyshi} % these two are required to add the little picture on top of every page
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\algnewcommand\AND{\textbf{and}\xspace}
\algnewcommand\OR{\textbf{or}\xspace}
\newcommand{\BigO}{\mathcal{O}}
\renewcommand{\appendixname}{Annexe}

\pagestyle{plain} % on headers or footers on the first page

\makeindex
\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.30\textwidth]{../img/logo.jpg}\par\vspace{1cm}
	{\scshape\LARGE Sorbonne Universit\'e \par}
	\vspace{1cm}
	{\scshape\Large 3I003 : Algorithmique\par}
	\vspace{1.5cm}
	{\Large \bfseries Projet :\par}
	{\huge\bfseries Confitures\par}
	\vspace{2cm}
	{\Large\itshape Ahmed Boukerram \par Angelo Ortiz\par}
	
	\vfill

% Bottom of the page
	{\large Licence d'Informatique\par}
	{\large Ann\'ee 2018/2019\par}
\end{titlepage}

%\newpage

%%The following loads the picture on top of every page, the numbers in \put() define the position on the page:
%\AddToShipoutPicture{\setlength\unitlength{0.1mm}\put(604,2522){\includegraphics[width=1.5cm]{logo.jpg}}}

%\pagestyle{cb} % now we want to have headers and footers

\tableofcontents

\newpage

\section{Introduction}
Sur un forum de cuisine, on pourrait trouver une question portant sur le nombre minimal de pots n\'ecessaires pour la pr\'eservation d'une certaine quantit\'e de confiture pr\'epar\'ee. Il est important de remplir au complet chaque bocal afin de prolonger au maximum le temps de conservation du produit. Mais la capacit\'e des bocaux n'est pas la m\^eme pour tous. C'est pourquoi on veut proposer des algorithmes r\'esolvant cette question : on se fixe pour objectif d'utiliser le moins possible de bocaux.

Pour d\'efinir ce probl\`eme, on dispose des donn\'ees suivantes. Il y a $S$ d\'ecigrammes de confiture que l'on doit verser dans des bocaux vides. On compte aussi plusieurs bocaux de diverses capacit\'es que l'on range en $k$ classes : chaque classe de bocal correspond \`a une capacit\'e distincte. On appellera {\itshape syst\`eme de capacit\'es} l'ensemble des capacit\'es dont on dispose. On note ces $k$ capacit\'es par un tableau $V$ de taille $k$ num\'erot\'e par ordre croissant :
\begin{itemize}[\textbullet]
 \item $V[1] < V[2] < \cdots < V[k]$ ; et
 \item chaque capacit\'e $V[i]$ est exprim\'ee par la quantit\'e en d\'ecigrammes que l'on peut mettre dans un bocal.
\end{itemize}

\smallskip
On se fixe aussi certaines contraintes qui garantissent l'existence d'une solution au probl\`eme :
\begin{itemize}[\textbullet]
 \item la quantit\'e $S$ est un nombre entier de d\'ecigrammes ;
 \item la capacit\'e minimal d'un bocal est 1 d\'ecigramme, i.e.\ $V[1] = 1$ ; et
 \item on dispose d'une tr\`es grande quantit\'e (suppos\'ee ainsi illimit\'ee) de bocaux de chacune des capacit\'es.
\end{itemize}
En effet, en tenant compte des trois hypoth\`eses, on remarque que l'on peut toujours verser la totalit\'e de confiture dans des pots de 1 d\'ecigramme.

\bigskip
Notre objectif est de remplir le moins possible de bocaux et qu'ils soient tous remplis exactement \`a sa capacit\'e maximale. Ainsi, \'etant donn\'es :
\begin{itemize}
 \item un syst\`eme de $k$ capacit\'es $V[i] \in \mathbb{N}$, $i \in \{1,\dotsc,k\}$ avec $V[1]=1$,
 \item et une quantit\'e totale $S \in \mathbb{N}$ de confiture,
\end{itemize}
le but est de d\'eterminer le nombre minimum de bocaux tels que la somme de leurs capacit\'es est \'egale \`a $S$. On cherche donc \`a retourner un couple $(n,A)$, o\`u $n$ est le nombre de bocaux utiilis\'es et $A$ est un tableau de taille $k$ tel que $A[i]$ repr\'esente le nombre de bocaux de capacit\'e $V[i]$ \`a remplir au complet. On a ainsi que $n = \sum_{i=1}^{k} A[i]$.

\bigskip
Les objectifs de ce projet sont l'analyse th\'eorique et la mise en \oe uvre de trois algorithmes r\'esolvant le probl\`eme d\'ecrit ci-dessus. Dans un premier temps, on formalise le probl\`eme et propose plusieurs algorithmes dont on fera l'analyse de complexit\'e. Dans un deuxi\`eme temps, on impl\'emente ces algorithmes au moyen du langage de programmation Python afin de v\'erifier exp\'erimentalement les complexit\'es trouv\'ees pre\'ec\'edemment.

\newpage
\part{Partie th\'eorique}

\section{Algorithme I : Recherche exhaustive}

\subsection*{Question 1}
Soit la propri\'et\'e suivante \( P_{1}(s) : \) \texttt{RechercheExhaustive}$(k,V,s)$ se termine et renvoie le nombre minimal de bocaux \`a remplir pour une quantit\'e $s$ de confiture avec un syst\`eme de $k$ capacit\'es d\'ecrit dans les cases du tableau $V[1..k]$.
Montrons-la par r\'ecurrence forte sur $s$.

\subsubsection*{Preuve}
\underline{Cas n\'egatif} : Pour $s < 0$, la quantit\'e de confiture est n\'egative. Dans ce cas-l\`a, on ne peut pas remplir les bocaux et on dit que le nombre de bocaux est infini. 
Par ailleurs, dans le corps de l'algorithme, on rentre dans le bloc \texttt{then} du premier branchement conditionnel et renvoie bien $+\infty$. De plus, on n'a effectu\'e que des instructions \'el\'ementaires en nombre fini.
De ces faits, \texttt{RechercheExhaustive} est valide et se termine.

\medskip
\underline{Base} : Pour \( s = 0\), la quantit\'e de confiture est nulle. Aussi, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{then} du deuxi\`eme branchement conditionnel. Donc, on renvoie $0$, ce qui est correct puisque aucun bocal ne doit \^etre rempli.

De la m\^eme mani\`ere que dans le cas o\`u $s<0$, on montre ici que l'algorithme se termine car la suite d'instructions effectu\'ees ne comporte que des instructions \'el\'ementaires.
De ces faits, $P_{1}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{1}(s) \) vraie pour tout \( s < s_0 \), pour un $s_0>0$ fix\'e. Montrons \( P_{1}(s_0) \) vraie.

Comme $s_0 > 0$, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{else} du deuxi\`eme branchement conditionnel. \todo{Continue}

On ne rentre pas dans le branchement conditionnel. Donc, on renvoie le maximum de deux expressions :
	
	\begin{itemize}
		\item $\texttt{tailleMaxRec}(a,i+1,j-1) + \texttt{e}(i,j)$. Par hypoth\`ese de r\'ecurrence, $P(p)$ est vraie pour $0 \leq p=j-i-2 < p_0$. De plus, d'apr\`es la remarque du cas n\'egatif, la fonction se termine et est valide lorsque $j-i-2<0$. Quant \`a \texttt{e}(i,j), cette fonction ne contient que des {\itshape IE} et donc se termine. De plus, elle est bien valide car la valeur de retour est $0$ ou $1$ selon la possibilit\'e de couplage entre $i$ et $j$.
		\item $\displaystyle\max_{i < k \leq j} {\texttt{tailleMaxRec}(a,i,k-1)+\texttt{tailleMaxRec}(a,k,j)}$. Pour tout $\\k \in \{i+1, \dotsc, j\}$, 
		\begin{itemize}
			\item $\texttt{tailleMaxRec}(a,i,k-1)$ finit et est valide par hypoth\`ese de r\'ecurrence : $0 \leq k-1-i < p_0$. 
			\item $\texttt{tailleMaxRec}(a,k,j)$ finit et est valide par hypoth\`ese de r\'ecurrence : $0 \leq j-k < p_0$.
		\end{itemize}
		Par ailleurs, la fonction \texttt{max} est finie et renvoie bien le maximum des $j-i$ valeurs de la somme.
	\end{itemize}
	
	Dans la deuxi\`eme partie de la question 3, on a montr\'e une formule calculant $E_{i,j}$, c'est-\`a-dire la taille maximale d'une s\'equence de taille $j-i+1$ avec $i<j$, ce qui est bien le cas ici. On sait que cette formule est transcrite dans le code de la fonction \texttt{tailleMaxRec}. De plus, on vient de montrer que la valeur de retour de la fonction est finie et correspond au maximum des deux arguments d\'ecrits ci-dessus. De ces faits, $P(p_0)$ est vraie.
	
\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{1}(0) \text{ vraie } \\
\forall s_0 \geq 1, [(\forall s < s_0, P_{1}(s)) \Rightarrow P_{1}(s_0) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, \texttt{RechercheExhaustive}(k,V,s) \\
\text{se termine et est valide.}
\end{array}\right .
\end{equation*}

\subsubsection*{Cas particulier}
D'apr\`es le r\'esultat pr\'ec\'edant, pour $s = S \in \mathbb{N}$ (la quantit\'e de confiture dans le cadre de ce projet), on a que l'algorithme est valide et se termine lorsqu'il est appel\'e par l'appel initial \texttt{RechercheExhaustive}$(k,V,S)$. 

\subsection*{Question 2}
Soient $b(s)$ et $c(s)$ les suites d\'efinies par
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
\end{equation*}
Soit $a(s)$ le nombre d'appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$.

\begin{enumerate}[a)]
\item La suite $a(s)$ est d\'efinie par
\[ a(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      a(s-2) + a(s-1) + 2 & \text{si } s\geq 2 
   \end{cases}
\]

\item Soit la propri\'ete suivante $P_{2}(s), s\geq 0$: $ b(s) \leq a(s) \leq c(s) $.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$. 

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $b(0) = a(0) = c(0) = 0 $. Donc, $P_{2}(0)$ est vraie.

Pour \( s = 1\), on a $b(1) = a(1) = c(1) = 2 $. Donc, $P_{2}(1)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{2}(s-2) \) et \( P_{2}(s-1) \) vraies pour un \( s \geq 2 \) fix\'e. Montrons \( P_{2}(s) \) vraie.

Par hypoth\`eses de r\'ecurrence, on a : 
\begin{alignat}{1}
b(s-2) &\leq a(s-2) \leq c(s-2) \\
b(s-1) &\leq a(s-1) \leq c(s-1)
\end{alignat} 

Par d\'efinition des suites r\'ecursives, on a :
\begin{alignat}{1}
b(s) &= 2\cdot b(s-2) + 2 \\
a(s) &= a(s-2) + a(s-1) + 2 \\
c(s) &= 2\cdot c(s-1) + 2
\end{alignat}

\'Etant donn\'e que les suites $b(s)$ et $c(s)$ sont croissantes (c.f.\ annexe \ref{appendix:suites}), les \'equations (1) et (2) deviennent
\begin{alignat*}{1}
b(s-2) &\leq a(s-2) \leq c(s-1) \\
b(s-2) &\leq a(s-1) \leq c(s-1)
\end{alignat*}

Il en r\'esulte que 
\begin{alignat}{1}
2\cdot b(s-2) + 2 &\leq a(s-2) + a(s-1) + 2 \leq 2\cdot c(s-1) + 2
\end{alignat}

En rempla\c{c}ant les d\'efinitions donn\'ees en (3), (4) et (5) dans (6), on obtient
$ b(s) \leq a(s) \leq c(s) $.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{2}(0) \text{ et } P_{2}(1) \text{ vraies } \\
\forall s \geq 2, [(P_{2}(s-2) \text{ et } P_{2}(s-1)) \Rightarrow P_{2}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq a(s) \leq c(s)
\end{array}\right .
\end{equation*}

\item Soit la propri\'ete suivante \( P_{3}(s) \), $s \geq 0$ : $c(s) = 2^{s+1} - 2$.
Montrons-la par r\'ecurrence faible sur s.

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $c(0) = 0 $. De plus, $ 2^{0+1} - 2 = 2^1 - 2 = 0$. Donc, $P_{3}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{3}(s) \) vraie pour un \( s \geq 0 \) fix\'e. Montrons \( P_{3}(s+1) \) vraie.

On a $ s+1 \geq 1 $. 
Par d\'efinition, $c(s+1) = 2\cdot c(s) + 2$. Or $c(s) = 2^{s+1} - 2$.

Donc, $c(s+1) = 2 \cdot (2^{s+1} - 2) + 2 = 2^{s+2} - 2$. D'o\`u, $P_{3}(s+1)$ est vraie.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{3}(0) \text{ vraie } \\
\forall s \geq 0, [P_{3}(s) \Rightarrow P_{3}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) = 2^{s+1} - 2
\end{array}\right .
\end{equation*}

\item \todo{Faire}

\item On d\'eduit des deux questions pr\'ec\'edentes que $ b(s) = 2^{\lceil \frac{s}{2} \rceil + 1} - 2 $.

D'apr\`es la question b), on a $ b(s) \leq a(s) \leq c(s) $. 

De ces faits, $ 2^{\lceil \frac{s}{2} \rceil + 1} - 2 \leq a(s) \leq 2^{s+1} - 2 $.

Consid\'erons seulement les appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$ pour le calcul de la complexit\'e temporelle de l'algorithme.
Donc, la complexit\'e pour le syst\`eme des deux capacit\'es minimales est donn\'ee par $a(s)$. Ainsi, la complexit\'e est exponentielle en $S$, \`a savoir la quantit\'e de confiture \`a notre disposition.

\end{enumerate}

\section{Algorithme II : Programmation dynamique}

\subsection*{Question 3}
On note $m(S)$ le nombre minimum de bocaux pour $S$ d\'ecigrammes de confiture et un tableau d capacit\'es $V$. On d\'efinit une famille de probl\`emes interm\'ediaires de la fa\c{c}on suivante : \'etant donn\'es un entier $s$ et un entier $i \in \{1, \dotsc, k\}$, on note $m(s,i)$ le nombre minimum de bocaux n\'ecessaires pour une quantit\'e totale $s$ en ne choisissant des bocaux que dans le syst\`eme de capacit\'es $V[1],V[2],\dotsc,V[i]$.

On pose :
\begin{align*}
 m(0,i) &= 0 & \forall & i \in \{1,\dotsc, k\} \\
 m(s,0) &= +\infty & \forall & s \geq 1 \\
 m(s,i) &= + \infty & \forall & i \in \{1,\dotsc,k\} \forall s < 0
\end{align*}

\begin{enumerate}[a)]
\item On a \( m(S) = m(S,k)\).
%\( m(S) = \displaystyle\min_{1 \leq i \leq k}{m(S,i)} \)

\item Soit la relation de r\'ecurrence suivante pour tout $ i \in \{1,\dotsc,k\} $
\[
m(s,i) = 
\begin{cases}
0 & \text{si } s = 0 \\
\min \{m(s,i-1),m(s-V[i],i)+1\} & \text{sinon}
\end{cases}
\]

\subsubsection*{Preuve}
Soit $s$ la capacit\'e de confiture \`a traiter. Deux cas sont possibles :\todo{r\'e currence double s, puis i}
\begin{enumerate}[i)]
 \item \underline{$s = 0$ :} Dans ce cas-l\`a, il n'y a pas de confiture \`a pr\'eserver. On n'utilise donc aucun bocal, i.e.\ on a $m(0,i) = 0$. \hfill\ensuremath{\blacksquare}
 \item \underline{$s \neq 0$ :} Puisque $m(s,i) = +\infty$ pour toute quantit\'e $s < 0$, la relation de r\'ecurrence ne concerne dans ce cas-l\`a que les quantit\'es $s > 0$. De m\^eme, on a $m(s,0) = +\infty$ pour toute quantit\'e $s \geq 1$. Donc, on ne consid\`ere que les $i > 0$.
 
\'Etant donn\'e le syst\`eme de capacit\'es $V[1], V[2], \dotsc, V[i]$, deux choix sont possibles : soit on utiilise des bocaux de capacit\'e $V[i]$, soit on ne s'en sert pas. 

D'un c\^ot\'e, le premier choix implique forc\'ement l'utilisation d'{\itshape au moins} un bocal de ladite capacit\'e. Ceci se traduit math\'ematiquement par $m(s-V[i],i)+1$. 

D'un autre c\^ot\'e, le deuxi\`eme choix rejete les bocaux de ladite capacit\'e. Donc, le r\'esultat est donn\'e par $m(s,i-1)$.

Comme on cherche \`a minimiser le nombre de bocaux \`a utiliser, $m(s,i)$ doit valoir le minimum entre ces deux r\'esultats. \hfill\ensuremath{\blacksquare}
\end{enumerate}
\end{enumerate}

\subsection*{Question 4}
Soit $M$ un tableau doublement indic\'e tel que la case $M[s,i]$, o\`u $s \in \{0,\dotsc,S\}$ et $i \in \{0,\dotsc,k\}$, contient la valeur $m(s,i)$.

\begin{enumerate}[a)]
 \item Soit le couple $(s,i) \in \{1,\dotsc,S\} \times \{1,\dotsc,k\}$. D'apr\`es la relation de r\'ecurrence prouv\'ee ci-dessus, pour calculer $m(s,i)$, on n\'ecessite des valeurs stock\'ees dans les cases $(s,i-1)$ et $(s-V[i],i)$, si $s-V[i] \geq 0$. Autrement dit, la case \`a gauche et toutes les cases au-dessus de $(s,i)$ doivent \^etre trait\'ees pr\'ealablement au calcul de la valeur de cette derni\`ere.
 
 Cela implique que le remplissage du tableau doit commencer \`a la case $(0,0)$ et aller jusqu'\`a la case $(S,k)$ en suivant un parcours matriciel. Cependant, ce parcours peut se faire par lignes ou par colonnes. 
 
 {\bfseries N.B.} Dans le cadre du projet, le parcours s\'equentiel des lignes a \'et\'e s\'electionn\'e.
 
 \item On d\'eduit des deux questions pr\'ec\'edentes un algorithme \texttt{AlgoProgDyn} qui pour un syst\`eme de $k$ capacit\'es $V[1],V[2],\dotsc,V[k]$ et une quantit\'e $S$ de confiture retourne $m(S)$. En voici le pseudocode :
 
\begin{algorithm}
\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{Main}{$k$: integer, $V$: $k$-integer array, $S$: integer}
    \State $M$: $S \times k$ integer matrix filled with $+\infty$
    \For{$s=0$ to $S$}
        \For{$i=0$ to $k$}
            \State $M[s][i] \gets $ \Call{GetMsi}{$V$, $M$, $s$, $i$}
        \EndFor
    \EndFor
    \State \Return $M[S][k]$\Comment{The value of $m(S)$}
\EndFunction
\Statex
\Function{GetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer matrix, $s$: integer, $i$: integer}
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \ElsIf {$M[s][i] < +\infty$}
    	\State \Return $M[s][i]$
    \Else 
        \State \Return $\min$(\Call{GetMsi}{$V$, $M$, $s$, $i-1$}, \Call{GetMsi}{$V$, $M$, $s-V[i]$, $i$} + 1)
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

 \item Pour l'analyse de la complexit\'e temporelle on utilise l'acc\`es \`a une case du tableau $M$ comme instruction \'el\'ementaire. Ainsi, on remarque que pour chaque case on acc\`ede au plus 3 fois \`a des \'el\'ements du tableau : l'une pour l'\'ecriture de la case et les deux restantes pour la lecture des cases dont on cherche le minimum des valeurs.
La complexit\'e temporelle de l'algorithme est donc en $\Theta(S\cdot k)$.

Quant \`a la complexit\'e spatiale, on se sert de deux structures de donn\'ees gourmandes, \`a savoir le tableau $V$ de $k$ cases d'entiers et la matrice $M$ de $S\cdot k$ cases d'entiers. En prenant comme taille de base celle d'un entier, on r\'ealise que la complexit\'e spatiale de l'algorithme est aussi en $\Theta(S\cdot k)$.
\end{enumerate}

\subsection*{Question 5}
On d\'esire \`a pr\'esent permettre \`a l'algorithme de retourner un tableau A indiquant le nombre de bocaux pris pour chaque type de capacit\'es.

\begin{enumerate}[a)]
 \item Dans un premier temps, on d\'ecide de placer dans chaque case du tableau $M[s,i]$, un tableau $A$ indiquant les bocaux pris pour la capacit\'e totale $s$ et des capacit\'es de bocaux prises parmi $V[1],\dotsc,V[i]$. 
 
 Pour ce faire, on effectue quelques modifications dans l'algorithme \texttt{AlgoProgDyn}. Tout d'abord, la matrice $M$ devient une matrice de tableaux d'entiers d'ordre $S \times k$. \todo{Ce qui suit est faux} Puis l'affectation de la case $M[s][i]$ \`a la ligne 5 devient un appel \`a la proc\'edure \textproc{SetMsi}($V$, $M$, $s$, $i$). Cette derni\`ere reprend la logique de la fonction \textproc{GetMsi}, sauf que l'on cr\'ee le tableau $A$ pour la case correspondante au lieu renvoyer le nombre total de bocaux utilis\'es. 
 
 \begin{algorithm}
%\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Function{GetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \Else
        \State $A \gets M[s][i]$
        \State \Return $\sum_{j=1}^{i} A[j]$
    \EndIf
\EndFunction
\Statex
\Function{SetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array filled with $i$ zeros
    \If {$s > 0$ \AND $i > 0$}
        \State $left \gets \Call{GetMsi}{V, M, s, i-1}$
        \State $up \gets \Call{GetMsi}{V, M, s-V[i], i}+1$
        \If {$left < up$}
            \State $A[1\dotsc i-1] \gets M[s][i-1]$
        \Else
            \State $A[1\dotsc i] \gets M[s-V[i]][i]$
            \State $A[i] \gets A[i] + 1$
        \EndIf
    \EndIf
    \State $M[s][i] \gets A$
\EndFunction
\end{algorithmic}
\end{algorithm}
 
 \item Dans un deuxi\`eme temps, on souhaite \'eviter de copier dans chaque case du tableau $M$, les tableaux $A$ des bocaux utilis\'es. Pour ce faire, on conserve l'algorithme initial et on reconstitue {\itshape a posteriori} le tableau $A$ de la solution optimale. Voici le pseudocode du deuxi\`eme algorithme :
 \begin{algorithm}
\caption{AlgoProgDynRet}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{ConfitureBackward}{$k$: integer, $V$: $k$-integer array, $S$: integer, $M$: $S \times k$ integer matrix}
    \State $A$: integer array fileld with $k$ zeros
    \State $s, i$: integers
    \State $s \gets S$
    \State $i \gets k$
    \While {$s \ne 0$}
        \If {$i > 0$ \AND $M[s][i] = M[s][i-1]$}
        \Comment {no more capacity $V[i]$}
            \State $i \gets i-1$
        \Else
        \Comment {$M[s][i] = M[s-V[i]][i] + 1$}
            \State $A[i] \gets A[i] + 1$
            \State $s \gets s - V[i]$
        \EndIf
    \EndWhile
    \State \Return $A$
\EndFunction
\end{algorithmic}
\end{algorithm}

%{\bfseries N.B.} Il est important de remarquer que, \'etant donn\'ee l'ordre des tests, cet algorithme privil\'egie la solution utilisant le plus grand nombre de bocaux de capacit\'es distinctes.
 
 Force est de constater que l'algorithme suit {\itshape dans le pire cas} un chemin de d\'eplacements unitaires dans le m\^eme sens de la case $(S,k)$ \`a la case $(0,0)$. C'est pourquoi on effectue {\itshape au plus} $S+k$ tours de boucle. On remarque aussi que le corps de la boucle comporte uniquement des instructions \'el\'ementaires. Ce morceau de l'algorithme est ainsi en $\BigO(S+k)$.
 
 Par ailleurs, l'initialisation du tableau $A$ est en $\Theta(k)$. On en d\'eduit que la compl\'exit\'e de l'algorithme de retour est en $\BigO(S+k)$. \todo{Complexit\'e totale ? que le retour ? spatiale ?}
\end{enumerate}


\subsection*{Question 6}
Soit \( u_p \) le nombre d'appels de la fonction \texttt{tailleMaxRec} effectu\'es pour \( p = j-i \).
\begin{enumerate}
	\item \( u_0 = 1 \) car on rentre dans le branchement conditionnel.
	
	\( u_1 = 4 \) car on ne rentre pas dans le branchement conditionnel et fait 1 appel pour le premier argument de la fonction \texttt{max} et 2 appels pour le deuxi\`eme argument.
	\item Soit \( p \geq 2 \). Soit la propri\'et\'e \( Q(p): u_p = u_{p-2} + 1 + 2\sum_{i=0}^{p-1}{u_i} \). 
	
	Montrons-la par d\'emonstration directe.
	
	Soit $p\geq 2$. Comme $p > 1$, on ne rentre pas dans le branchement conditionnel de la fonction \texttt{tailleMaxRec}. Donc, on renvoie le maximum de deux expressions :
	
	\begin{itemize}
		\item $\texttt{tailleMaxRec}(a,i+1,j-1) + \texttt{e}(i,j)$. Ici, le nombre d'appels \`a la fonction est $u_{p-2}$ car $j-1-(i+1)=j-i-2=p-2$.
		\item \( \displaystyle\max_{i < k \leq j} {\texttt{tailleMaxRec}(a,i,k-1)+\texttt{tailleMaxRec}(a,k,j)} \). Pour tout $\\k \in \{i+1, \dotsc, j\}$, 
		\begin{itemize}
			\item $\texttt{tailleMaxRec}(a,i,k-1)$ r\'ealise $u_{k-1-i}$ appels \`a la fonction. 
			\item $\texttt{tailleMaxRec}(a,k,j)$ r\'ealise $u_{j-k}$ appels \`a la fonction.
		\end{itemize}
	\end{itemize}
	Donc, on a $u_p=u_{p-2}+1+\sum_{k=i+1}^{j}{u_{k-1-i}+u_{j-k}}$. 
	
	D'abord, on r\'e-indexe la somme : $u_p=u_{p-2}+1+\sum_{k=0}^{j-i-1}{u_{k}+u_{j-k-i-1}}$. 
	
	Or, $p=j-i$. Donc, on s\'epare les termes : $\\u_p=u_{p-2}+1+\sum_{k=0}^{p-1}{u_{k}}+\sum_{k=0}^{p-1}{u_{p-1-k}}$. 
	
	Puis, on inverse l'indice de la deuxi\`eme somme : $\\u_p=u_{p-2}+1+\sum_{k=0}^{p-1}{u_{k}}+\sum_{k=0}^{p-1}{u_{k}}$. 
	
	Finalement, on peut changer la variable des sommes et les regrouper : 
	\begin{gather*}
	u_p=u_{p-2}+1+2\sum_{i=0}^{p-1}{u_{i}}.
	\tag*{$\square$}
	\end{gather*}
	
	\item Soit la propri\'et\'e \( R(p): 2^p \leq u_p \leq 4^p \). 
	
	Montrons-la par r\'ecurrence forte sur {\itshape p}.
	
	\underline{Base} : Pour \( p = 0\), d'apr\`es la sous-question 1, \( 2^0 = 1 \leq u_0 = 1 \leq 1 = 4^0 \). Donc, \( R(0) \) est vraie.
	
	Pour \( p = 1\), d'apr\`es la sous-question 1, \( 2^1 = 2 \leq u_1 = 4 \leq 4 = 4^1 \). Donc, \( R(1) \) est vraie.
	
	\underline{Induction} : Supposons \( R(p) \) vraie pour tout \( p < p_0 \), pour un \( p_0 > 1 \) fix\'e. Montrons \( R(p_0) \) vraie.
	
	D'apr\`es la sous-question 2, \( u_{p_0} = u_{p_0-2} + 1 + 2\sum_{i=0}^{p_0-1}{u_i} \). 
	
	Or, par hypoth\`ese de r\'ecurrence, pour tout \( i \in \{0,\dotsc,p_0-1 \}, Q(i) \) est vraie. Donc, \( 2^{p_0-2} + 1 + 2\sum_{i=0}^{p_0-1}{2^i} \leq u_{p_0} \leq 4^{p_0-2} + 1 + 2\sum_{i=0}^{p_0-1}{4^i} \). D'o\`u, \( 2^{p_0-2} + 1 + 2\dfrac{2^{p_0}-1}{2-1} \leq u_{p_0} \leq 4^{p_0-2} + 1 + 2\dfrac{4^{p_0}-1}{4-1} \), c'est-\`a-dire \(\\ 2^{p_0} \leq 2^{p_0-2} + 2^{p_0+1} - 1 \leq u_{p_0} \leq 4^{p_0-2} + 2\dfrac{4^{p_0}}{3} + \dfrac{1}{3} \leq 4^{p_0}  \).
	
	\underline{Conclusion} : 
	\begin{equation*}
\left .\begin{array}{l}
R(0), R(1) \text{ vraies } \\
\forall p_0 \in \{2,\dotsc, n-1\}, [(\forall p < p_0, R(p)) \implies R(p_0) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall p \in \{0,\dotsc, n-1\}, \\
2^p \leq u_p \leq 4^p
\end{array}\right .
\end{equation*}

\item D'une part, d'apr\`es le paragraphe pr\'ec\'edent, $R(n-1)$ est vraie, c'est-\`a-dire \( 2^{n-1} \leq u_{n-1} \leq 4^{n-1} \), o\`u \( n = p+1=j-i+1 \) est la longueur de la s\'equence. 

D'autre part, chaque appel \`a \texttt{tailleMaxRec} ne contient que des {\itshape IE} \`a part ses appels r\'ecursifs (on consid\`ere que la fonction \texttt{max} est optimale et fait donc les comparaisons {\itshape in situ}).

Donc, on peut exprimer la complexit\'e de la fonction en nombre d'appels r\'ecursifs effectu\'es. De ce fait, la complexit\'e de \texttt{tailleMaxRec} est en $\Omega(2^n)$ et $\mathcal{O}(4^n)$.
\end{enumerate}

\section{Algorithme III : Cas particulier et algorithme glouton}

\subsection*{Question 7}
On utilisera un tableau \`a deux dimensions pour stocker les valeurs de \( E_{i,j} \). De plus, on consid\`erera que l'acc\`es \`a une case du tableau et l'appel \`a \texttt{e()} sont des instructions \'el\'ementaires  compte tenu de leur complexit\'e : $\Theta(1)$. 

Tout d'abord, on initialise la premi\`ere case de la premi\`ere ligne \`a 0. Donc, la complexit\'e de cette partie est en $\Theta(1)$. 

Puis, la premi\`ere boucle \texttt{for} est effectu\'ee \( n-1 \) fois et \`a chaque tour de boucle on ne r\'ealise que des {\itshape IE}. Donc, la complexit\'e de cette partie est en $\Theta(n)$. 

Finalement, on effectue deux boucles l'une \`a l'int\'erieur de l'autre. La boucle imbriqu\'ee consiste en le calcul du maximum de deux expressions. Les op\'erations arithm\'etiques n'\'etant pas d'instructions repr\'esentatives, la premi\`ere d'entre elles comprend deux {\itshape IE}. En ce qui concerne le deuxi\`eme argument, le nombre d'{\itshape IE} effectu\'ees est \( 2p \). Donc, le nombre d'{\itshape IE} r\'ealis\'ees dans cette partie est \( \\c = \sum_{p=1}^{n-1}\sum_{i=1}^{n-p}{2p+2} = \sum_{p=1}^{n-1}{(2p+2)(n-p)} = 2\sum_{p=1}^{n-1}{[p(n-1)+n-p^2]} \). D'o\`u, \( c = (n-1)^2n + 2(n-1)n - \dfrac{(n-1)n(2n-1)}{3} = \dfrac{(n-1)n(n+4)}{3} \). Donc, la complexit\'e de cette partie est en $\Theta(n^3)$.

De ces trois faits, on en d\'eduit que la complexit\'e de l'algorithme est en $\Theta(n^3)$.
%Le co\^ut en temps d'ex\'ecution du calcul de l

\lstset{language=Python,inputencoding=utf8/latin1}
\lstdefinestyle{custompy}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  %frame=L,
  xleftmargin=\parindent,
  language=Python,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstset{escapechar=@,style=custompy}
\newpage
\part{Mise en \oe uvre}

\section{Impl\'ementation}
Le but de ce second exercice est de mesurer de mani\`ere exp\'erimentale la complexit\'e de la fonction \texttt{tailleMaxRec} et de l'algorithme d\'ecrit dans la question 5 de l'exercice pr\'ec\'edent. Le choix du langage de programmation est libre. La complexit\'e exp\'erimentale de l'ex\'ecution d'une fonction correspond ici au temps qu'il faut pour que la fonction s'ex\'ecute.

Dans cet exercice, {\itshape n} d\'esigne la taille de la s\'equence initiale.

\subsection*{Question 1}
Voici le code des fonctions \texttt{e}, \texttt{maximum}, \texttt{tailleMaxRec} et \texttt{tailleMaxIter}.
\begin{lstlisting}[mathescape]

def e(a,i,j):
    """ str x int x int -> bool
    rend True si i et j peuvent être couplés dans a, False sinon
    """
    # couples : list[tuple[str]]
    couples = [('A','T'),('A','T'),('G','C'),('C','G')]
    if (a[i-1],a[j-1]) in couples:
        return True
    return False

def maximum(a,i,j):
    """ str x int x int -> int
    rend le nombre de couples de la structure secondaire de taille maximale obtenue pour l'un des partitionnements de la sous-séquence $\color{purple!40!black}a_{i,j}$
    """
    # maxi : int
    maxi = 0
    # k : int
    for k in range(i,j):
        # val : int
        val = tailleMaxRec(a,i-1,k-1)+tailleMaxRec(a,k,j-1)
        if val > maxi:
            maxi = val
    return maxi

def tailleMaxRec(a,i,j):
    """ str x int x int -> int
    rend le nombre de couples de la structure secondaire de taille maximale de la sous-séquence $\color{purple!40!black}a_{i,j}$
    """
    if j-i < 1:
        return 0
    return max(tailleMaxRec(a,i+1,j-1) + e(a,i,j), \
                            maximum(a,i+1,j+1))




def tailleMaxIter(a,i,j):  
    """ str x int x int -> list[list[int]]
    rend un tableau à 2 dimensions contenant le nombre de couples de la structure secondaire de taille maximale de chaque sous-sequence $\color{purple!40!black}a_{k,l}$ avec $\color{purple!40!black}i \leq k,l \leq j$ et $\color{purple!40!black}k \leq l$
    """
    # n : int
    n = len(a)
    # E : list[list[int]]
    E = [[0]]
    # i : int
    for i in range(2,n+1,1):
        E.append([0]*i)
    # p : int
    for p in range(1,n):
        for i in range(1,n-p+1):
            E[i-1].append(max(E[i][i+p-2]+e(a,i,i+p), \
                   max(E[i-1][k-2]+E[k-1][i+p-1] \
                       for k in range(i+1,i+p+1))))
    return E[i-1][j-1]
\end{lstlisting}


Voici un jeu d'essai.
% \begin{figure}[!h]
% %\includegraphics[width=\columnwidth]{filename}%
% \fbox{\includegraphics[width=\columnwidth]{jeu.png}}
% \end{figure}

\newpage
\subsection*{Question 2}
Voici le code de la fonction \texttt{SeqAleatoire(n)} qui renvoie une s\'equence d'ADN al\'eatoire de taille {\itshape n}.
\begin{lstlisting}

import random

def SeqAleatoire(n):
    """ int -> str
    rend une séquence aléatoire d'ADN de taille n 
    """
    seq = ''
    for i in range(n):
        seq += random.choice('AGCT')
    return seq
\end{lstlisting}

\subsection*{Question 3}
La plus grande valeur de $n$ que l'on peut traiter sans probl\`eme de m\'emoire ou de temps d'ex\'ecution de quelques minutes pour la fonction \texttt{tailleMaxRec} est 18. 

Quant \`a \texttt{tailleMaxIter}, la valeur de $n$ correspondante est 1600.

\subsection*{Question 4}
On a mis dans le tableau ci-dessous le temps d'ex\'ecution de plusieurs appels \`a la fonction \texttt{tailleMaxRec} selon les valeurs de $n$.
	\begin{center}
	\begin{tabular}{|c|cc|}
	\hline $n$ & $CRec(n)$ (en s.) & $\log CRec(n)$ \\
	\hline 11 &   0.0915572 & -1.0383075 \\ 
	\hline 12 &   0.3087260 & -0.5104268 \\ 
	\hline 13 &   0.9356748 & -0.0288751 \\ 
	\hline 14 &   3.0208589 &  0.4801304 \\
	\hline 15 &   9.7992974 &  0.9911949 \\ 
	\hline 16 &  30.8693360 &  1.4895273 \\ 
	\hline 17 & 100.5011405 &  2.0021710 \\
	\hline 18 & 322.5870859 &  2.5086470 \\
	\hline
	\end{tabular}
	\end{center}
	
	On en d\'eduit la droite de r\'egression de $\log CRec(n)$ en fonction de $n$ : $\\\Delta : y = 0.505452x - 6.592292$. On remarque que la pente de la droite est $0.505452$, ce qui \'etait attendu car la valeur est comprise entre $\log 2 = 0.301030$ et $\\\log 4 = 0.602060$. 
	%On remarque que la fonction $\log CRec(n)$ est lin\'eaire compte tenu que les points forment une droite dont la pente est $0.5108032$ et l'\'ecart type est $\sigma = 0.0075038$.

\newpage
\subsection*{Question 5}
On a mis dans le tableau ci-dessous le temps d'ex\'ecution de plusieurs appels \`a la fonction \texttt{tailleMaxIter} selon les valeurs de $n$.
	\begin{center}
	\begin{tabular}{|c|cc|}
	\hline $n$ & $CIter(n)$ (en s.) & $\dfrac{CIter(n)}{n^3}$ \\[6pt]
	\hline 200 & 0.5192115 & $\num{6.4901434E-08}$ \\ 
	\hline 400 & 4.1114257 & $\num{6.4241026E-08}$ \\ 
	\hline 600 & 14.2562266 & $\num{6.6001049E-08}$ \\ 
	\hline 800 & 34.8566699 & $\num{6.8079433E-08}$ \\
	\hline 1000 & 71.8084174 & $\num{7.1808417E-08}$ \\ 
	\hline 1200 & 124.3441816 & $\num{7.1958438E-08}$ \\ 
	\hline 1400 & 200.7089246 & $\num{7.3144652E-08}$ \\
	\hline 1600 & 314.0727653 & $\num{7.6677921E-08}$ \\
	\hline
	\end{tabular}
	\end{center}
	
	On en d\'eduit la droite de r\'egression de $\dfrac{CIter(n)}{n^3}$ en fonction de $n$ : $\\\Delta : y = \num{8.842541E-12}x - \num{6.164326E-08}$. On remarque l'ordre de grandeur de la pente de la droite : $\num{8.842541E-12} \ll 1$. Ceci implique que la fonction est bien constante de valeur $\num{6.9601546E-08}$. 
	%On remarque que la fonction $\dfrac{CIter(n)}{n^3}$ est constante compte tenu que les points forment la droite $\Delta : y = \num{7.3965667e-08}$ avec un \'ecart type ${\sigma = \num{5.8075249e-09}}$.

\newpage
\begin{appendices}
 \section{Suites croissantes}
 \label{appendix:suites}
 On rappelle la d\'efinition des suites $b(s)$ et $c(s)$ comme suit :
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      %2 & \text{si } s = 1 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 1 
   \end{cases} \right.
\end{equation*}

Montrons que les deux suites sont croissantes.

\subsection*{Suite $b(s)$}
Soit la propri\'et\'e suivante $Q_{1}(s), s \geq 0$ : $b(s) \leq b(s+1)$.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$

\subsubsection*{Preuve}
\underline{Base} : On a $b(0) = 0 \leq 2 = b(1) \leq 2\cdot 0 + 2 = b(2)$. 
Donc, la propri\'et\'e est v\'erifi\'ee aux rangs 0 et 1.

\medskip
\underline{Induction} : Supposons $Q_{1}(s-2)$ et $Q_{1}(s-1)$ vraies pour un $s \geq 2$ fix\'e. 
Montrons $Q_{1}(s)$ vraie.

\smallskip
Par hypoth\`ese de r\'ecurrence, $b(s-2) \leq b(s-1)$. D'o\`u, $2\cdot b(s-2)+2 \leq 2\cdot b(s-1)+2$.
Or, par d\'efinition, $b(s+1) = 2\cdot b(s-1) + 2$.
Donc, $b(s) \leq b(s+1)$, i.e.\ la propri\'et\'e est v\'erifi\'ee au rang $s$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{1}(0) \text{ et } Q_{1}(1) \text{ vraies } \\
\forall s \geq 2, [(Q_{1}(s-2) \text{ et } Q_{1}(s-1)) \Rightarrow Q_{1}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq b(s+1)
\end{array}\right .
\end{equation*}

On remarque que ceci correspond \`a la d\'efinition d'une suite croissante. \hfill\ensuremath{\blacksquare}

\subsection*{Suite $c(s)$}
Soit la propri\'et\'e suivante $Q_{2}(s), s \geq 0$ : $c(s) \geq 0$.
Montrons-la par r\'ecurrence faible sur $s$.

\subsubsection*{Preuve}
\underline{Base} : Pour $s = 0$, on a $c(0) = 0 \geq 0$. 
Donc, la propri\'et\'e est v\'erifi\'e aux rang 0.

\medskip
\underline{Induction} : Supposons $Q_{2}(s)$ vraie pour un $s \geq 0$ fix\'e. 
Montrons $Q_{2}(s+1)$ vraie.

\smallskip
Par d\'efinition, $c(s+1) = 2\cdot c(s) + 2$.
Or, par hypoth\`ese de r\'ecurrence, $c(s) \geq 0$. D'o\`u, $2\cdot c(s)+2 \geq 2$.
Donc, $c(s+1) \geq 2 \geq 0$. On en d\'eduit par transitivit\'e que la propri\'et\'e est v\'erifi\'ee au rang $s+1$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{2}(0) \text{ vraie } \\
\forall s \geq 0, [Q_{2}(s) \Rightarrow Q_{2}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) \geq 0
\end{array}\right .
\end{equation*}

Par ailleurs, on a $c(s) = 2\cdot c(s-1) + 2, s \geq 1$. D'o\`u, $c(s) \geq 2\cdot c(s-1)$.
Comme cette suite est positive, on sait que $2\cdot c(s-1) \geq c(s)$. Donc, par transitivit\'e, $c(s) \geq c(s-1)$. Autrement dit, pour tout $s \geq 0$, $c(s+1) \geq c(s)$. 
\hfill\ensuremath{\blacksquare}

\newpage
\section{Complexit\'e de \texttt{RechercheExhaustive} dans le cas g\'en\'eral}

\end{appendices}
	
\printindex
\end{document}



