\documentclass[12pt,a4paper]{article}

%########################### Preferences #################################


% ******** vmargin settings *********
\usepackage{vmargin} %This give you full control over the used page arae, it maybe not the idea od Latex to do so, but I wanted to reduce to amount of white space on the page
\setpapersize{A4}
\setmargins{3cm}%			%linker Rand, left edge
					 {1.5cm}%     %oberer Rand, top edge
           {14.7cm}%		%Textbreite, text width
           {23.42cm}%   %Texthoehe, text hight
           {14pt}%			%Kopfzeilenhöhe, header hight
           {1cm}%   	  %Kopfzeilenabstand, header distance
           {0pt}%				%Fußzeilenhoehe footer hight
           {2cm}%    	  %Fusszeilenabstand, footer distance

% ********* Font definiton ************
\usepackage{t1enc} % as usual
\usepackage[utf8]{inputenc} % as usual
\usepackage[french]{babel}
\usepackage{makeidx}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{listingsutf8}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage[shortlabels]{enumitem} 
\usepackage{siunitx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage[T1]{fontenc}
\usepackage[titletoc]{appendix}

% ********* Graphics definition *******
\usepackage[pdftex]{graphicx} % required to import graphic files
\usepackage{eso-pic} % these two are required to add the little picture on top of every page
\usepackage{everyshi} % these two are required to add the little picture on top of every page
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\algnewcommand\AND{\textbf{and}\xspace}
\algnewcommand\OR{\textbf{or}\xspace}
\newcommand{\BigO}{\mathcal{O}}
\renewcommand{\appendixname}{Annexe}
\hypersetup{
    colorlinks  = true,
    linkcolor   = red,
    citecolor   = blue,
    urlcolor    = blue,
    linktocpage = true
}

\pagestyle{plain} % on headers or footers on the first page

\makeindex
\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.30\textwidth]{../img/logo.jpg}\par\vspace{1cm}
	{\scshape\LARGE Sorbonne Universit\'e \par}
	\vspace{1cm}
	{\scshape\Large 3I003 : Algorithmique\par}
	\vspace{1.5cm}
	{\Large \bfseries Projet :\par}
	{\huge\bfseries Confitures\par}
	\vspace{2cm}
	{\Large\itshape Ahmed Boukerram \par Angelo Ortiz\par}
	
	\vfill

% Bottom of the page
	{\large Licence d'Informatique\par}
	{\large Ann\'ee 2018/2019\par}
\end{titlepage}

%\newpage

%%The following loads the picture on top of every page, the numbers in \put() define the position on the page:
%\AddToShipoutPicture{\setlength\unitlength{0.1mm}\put(604,2522){\includegraphics[width=1.5cm]{logo.jpg}}}

%\pagestyle{cb} % now we want to have headers and footers

\tableofcontents

\newpage

\section{Introduction}
Sur un forum de cuisine, on pourrait trouver une question portant sur le nombre minimal de pots n\'ecessaires pour la pr\'eservation d'une certaine quantit\'e de confiture pr\'epar\'ee. Il est important de remplir au complet chaque bocal afin de prolonger au maximum le temps de conservation du produit. Mais la capacit\'e des bocaux n'est pas la m\^eme pour tous. C'est pourquoi on veut proposer des algorithmes r\'esolvant cette question : on se fixe pour objectif d'utiliser le moins possible de bocaux.

Pour d\'efinir ce probl\`eme, on dispose des donn\'ees suivantes. Il y a $S$ d\'ecigrammes de confiture que l'on doit verser dans des bocaux vides. On compte aussi plusieurs bocaux de diverses capacit\'es que l'on range en $k$ classes : chaque classe de bocal correspond \`a une capacit\'e distincte. On appellera {\itshape syst\`eme de capacit\'es} l'ensemble des capacit\'es dont on dispose. On note ces $k$ capacit\'es par un tableau $V$ de taille $k$ num\'erot\'e par ordre croissant :
\begin{itemize}[\textbullet]
 \item $V[1] < V[2] < \cdots < V[k]$ ; et
 \item chaque capacit\'e $V[i]$ est exprim\'ee par la quantit\'e en d\'ecigrammes que l'on peut mettre dans un bocal.
\end{itemize}

\smallskip
On se fixe aussi certaines contraintes qui garantissent l'existence d'une solution au probl\`eme :
\begin{itemize}[\textbullet]
 \item la quantit\'e $S$ est un nombre entier de d\'ecigrammes ;
 \item la capacit\'e minimal d'un bocal est 1 d\'ecigramme, i.e.\ $V[1] = 1$ ; et
 \item on dispose d'une tr\`es grande quantit\'e (suppos\'ee ainsi illimit\'ee) de bocaux de chacune des capacit\'es.
\end{itemize}
En effet, en tenant compte des trois hypoth\`eses, on remarque que l'on peut toujours verser la totalit\'e de confiture dans des pots de 1 d\'ecigramme.

\bigskip
Notre objectif est de remplir le moins possible de bocaux et qu'ils soient tous remplis exactement \`a sa capacit\'e maximale. Ainsi, \'etant donn\'es :
\begin{itemize}
 \item un syst\`eme de $k$ capacit\'es $V[i] \in \mathbb{N}$, $i \in \{1,\dotsc,k\}$ avec $V[1]=1$,
 \item et une quantit\'e totale $S \in \mathbb{N}$ de confiture,
\end{itemize}
le but est de d\'eterminer le nombre minimum de bocaux tels que la somme de leurs capacit\'es est \'egale \`a $S$. On cherche donc \`a retourner un couple $(n,A)$, o\`u $n$ est le nombre de bocaux utiilis\'es et $A$ est un tableau de taille $k$ tel que $A[i]$ repr\'esente le nombre de bocaux de capacit\'e $V[i]$ \`a remplir au complet. On a ainsi que $n = \sum_{i=1}^{k} A[i]$.

\bigskip
Les objectifs de ce projet sont l'analyse th\'eorique et la mise en \oe uvre de trois algorithmes r\'esolvant le probl\`eme d\'ecrit ci-dessus. Dans un premier temps, on formalise le probl\`eme et propose plusieurs algorithmes dont on fera l'analyse de complexit\'e. Dans un deuxi\`eme temps, on impl\'emente ces algorithmes au moyen du langage de programmation Python afin de v\'erifier exp\'erimentalement les complexit\'es trouv\'ees pre\'c\'edemment.

\newpage
\part{Partie th\'eorique}

\section{Algorithme I : Recherche exhaustive}

\subsection*{Question 1}
Soit la propri\'et\'e suivante \( P_{1}(s) : \) \texttt{RechercheExhaustive}$(k,V,s)$ se termine et renvoie le nombre minimal de bocaux \`a remplir pour une quantit\'e $s$ de confiture avec un syst\`eme de $k$ capacit\'es d\'ecrit dans les cases du tableau $V[1..k]$.
Montrons-la par r\'ecurrence forte sur $s$.

\subsubsection*{Preuve}
\underline{Cas n\'egatif} : Pour $s < 0$, la quantit\'e de confiture est n\'egative. Dans ce cas-l\`a, on ne peut pas remplir les bocaux et on dit que le nombre de bocaux est infini. 
Par ailleurs, dans le corps de l'algorithme, on rentre dans le bloc \texttt{then} du premier branchement conditionnel et renvoie bien $+\infty$. De plus, on n'a effectu\'e que des instructions \'el\'ementaires en nombre fini.
De ces faits, \texttt{RechercheExhaustive} est valide et se termine.

\medskip
\underline{Base} : Pour \( s = 0\), la quantit\'e de confiture est nulle. Aussi, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{then} du deuxi\`eme branchement conditionnel. Donc, on renvoie $0$, ce qui est correct puisque aucun bocal ne doit \^etre rempli.

De la m\^eme mani\`ere que dans le cas o\`u $s<0$, on montre ici que l'algorithme se termine car la suite d'instructions effectu\'ees ne comporte que des instructions \'el\'ementaires.
De ces faits, $P_{1}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{1}(s) \) vraie pour tout \( s < s_0 \), pour un $s_0>0$ fix\'e. Montrons \( P_{1}(s_0) \) vraie.

Comme la quantit\'e de confiture $s_0$ est positive, on a besoin d'{\itshape au moins} un bocal o\`u la verser. On remarque qu'il n'y a pas de contrainte sur ce premier bocal. Pour s'assurer de bien calculer le nombre minimum de bocaux \`a remplir, on essaie donc toutes les capacit\'es possibles pour le premier bocal, puis on r\'esout les probl\`emes r\'ecursifs induits. Aussi, il suffit de choisir la configuration optimale parmi les $k$ possibles.

Par ailleurs, en ce qui concerne l'algorithme \texttt{RechercheExhaustive}, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{else} du deuxi\`eme branchement conditionnel, puisque $s_0 > 0$. On sait que la capacit\'e minimum est 1 \si{dg}. On en d\'eduit que le nombre {\itshape maximum} de bocaux \`a utiliser est $s_0$. 

On cherche \`a am\'eliorer la solution de d\'epart. Pour ce faire, on teste chaque capacit\'e $V[i], i \in \{1, \dotsc, k \}$, pour le premier bocal \`a remplir. Il reste ainsi $s_0-V[i]$ d\'ecigrammes de confiture \`a verser. D'apr\`es les conditions du probl\`eme, $V[i] \geq 1$, d'o\`u $s_0-V[i] < s_0$. Par hyporh\`ese de r\'ecurrence, \texttt{RechercheExhaustive}$(k,V,s)$, avec $s=s_0-V[i]$, se termine et est valide. On rajoute 1 \`a cette solution en raison du premier choix. On teste ensuite si cette derni\`ere am\'eliore la solution courante ; le cas \'ech\'eant, on met \`a jour la solution courante. On r\'ep\`ete ce proc\'ed\'e pour chacune des capacit\'es du tableau $V[1..k]$. 

Comme mentionn\'e pr\'ec\'edemment, \`a la fin de l'examen des $k$ capacit\'es pour le premier bocal, on se retrouve avec la solution optimale. 
\'Etant donn\'e que l'appel \texttt{RechercheExhaustive}$(k, V, s_0)$ renvoie cette solution optimale, il est valide. 
Par ailleurs, par hypoth\`eses de r\'ecurrence, les appels r\'ecursifs se terminent. On effectue $k$ tours de boucle du bloc \texttt{for} qui contient ces appels r\'ecursifs et quelques instructions \'el\'ementaires de plus.
On en d\'eduit que \texttt{RechercheExhaustive}$(k, V, s_0)$ se termine.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{1}(0) \text{ vraie } \\
\forall s_0 > 0, [(\forall s < s_0, P_{1}(s)) \Rightarrow P_{1}(s_0) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, \texttt{RechercheExhaustive}(k,V,s) \\
\text{se termine et est valide.}
\end{array}\right .
\end{equation*}

\subsubsection*{Cas particulier}
D'apr\`es le r\'esultat pr\'ec\'edant, pour $s = S \in \mathbb{N}$ (la quantit\'e de confiture dans le cadre de ce projet), on a que l'algorithme est valide et se termine lorsqu'il est appel\'e par l'appel initial \texttt{RechercheExhaustive}$(k,V,S)$. 

\subsection*{Question 2}
Soient $b(s)$ et $c(s)$ les suites d\'efinies par
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
\end{equation*}

Supposons que les seules capacit\'es de bocal disponibles sont 1 \si{dg} et 2 \si{dg}. Soit $a(s)$ le nombre d'appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$.

\begin{enumerate}[a)]
\item La suite $a(s)$ est d\'efinie par
\[ a(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      a(s-2) + a(s-1) + 2 & \text{si } s\geq 2 
   \end{cases}
\]

\item Soit la propri\'ete suivante $P_{2}(s), s\geq 0$: $ b(s) \leq a(s) \leq c(s) $.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$. 

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $b(0) = a(0) = c(0) = 0 $. Donc, $P_{2}(0)$ est vraie.

Pour \( s = 1\), on a $b(1) = a(1) = c(1) = 2 $. Donc, $P_{2}(1)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{2}(s-2) \) et \( P_{2}(s-1) \) vraies pour un \( s \geq 2 \) fix\'e. Montrons \( P_{2}(s) \) vraie.

D'apr\`es les hypoth\`eses de r\'ecurrence, on a : 
\begin{alignat}{1}
b(s-2) &\leq a(s-2) \leq c(s-2) \\
b(s-1) &\leq a(s-1) \leq c(s-1)
\end{alignat} 

Par d\'efinition de ces suites r\'ecursives, on a :
\begin{alignat}{1}
b(s) &= 2\cdot b(s-2) + 2 \\
a(s) &= a(s-2) + a(s-1) + 2 \\
c(s) &= 2\cdot c(s-1) + 2
\end{alignat}

\'Etant donn\'e que les suites $b(s)$ et $c(s)$ sont croissantes (c.f.\ annexe \hyperref[appendix:suites]{A}), les in\'egalit\'es (1) et (2) deviennent respectivement
\begin{alignat*}{1}
b(s-2) &\leq a(s-2) \leq c(s-1) \\
b(s-2) &\leq a(s-1) \leq c(s-1)
\end{alignat*}

Il en r\'esulte que 
\begin{alignat}{1}
2\cdot b(s-2) + 2 &\leq a(s-2) + a(s-1) + 2 \leq 2\cdot c(s-1) + 2
\end{alignat}

En rempla\c{c}ant les expressions (3), (4) et (5) en (6), on obtient
$ b(s) \leq a(s) \leq c(s) $.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{2}(0) \text{ et } P_{2}(1) \text{ vraies } \\
\forall s \geq 2, [(P_{2}(s-2) \text{ et } P_{2}(s-1)) \Rightarrow P_{2}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq a(s) \leq c(s)
\end{array}\right .
\end{equation*}

\item Soit la propri\'ete suivante \( P_{3}(s) \), $s \geq 0$ : $c(s) = 2^{s+1} - 2$.
Montrons-la par r\'ecurrence faible sur s.

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $c(0) = 0 $. De plus, $ 2^{0+1} - 2 = 2^1 - 2 = 0$. Donc, $P_{3}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{3}(s) \) vraie pour un \( s \geq 0 \) fix\'e. Montrons \( P_{3}(s+1) \) vraie.

On a $ s+1 \geq 1 $. 
Par d\'efinition, $c(s+1) = 2\cdot c(s) + 2$. Or $c(s) = 2^{s+1} - 2$.

Donc, $c(s+1) = 2 \cdot (2^{s+1} - 2) + 2 = 2^{s+2} - 2$. D'o\`u, $P_{3}(s+1)$ est vraie.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{3}(0) \text{ vraie } \\
\forall s \geq 0, [P_{3}(s) \Rightarrow P_{3}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) = 2^{s+1} - 2
\end{array}\right .
\end{equation*}

\item \todo{Faire}

\item On d\'eduit des deux questions pr\'ec\'edentes que $ b(s) = 2^{\lceil \frac{s}{2} \rceil + 1} - 2 $.

D'apr\`es la question b), on a $ b(s) \leq a(s) \leq c(s) $. 

De ces faits, $ 2^{\lceil \frac{s}{2} \rceil + 1} - 2 \leq a(s) \leq 2^{s+1} - 2 $.

Pour le calcul de la complexit\'e temporelle de l'algorithme, consid\'erons seulement les appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$.
La complexit\'e pour ce syst\`eme de deux capacit\'es est donn\'ee par $a(S)$. Ainsi, la complexit\'e est en $\Omega(\sqrt{2}^S)$ et $\mathcal{O}(2^S)$.

\end{enumerate}

\section{Algorithme II : Programmation dynamique}

\subsection*{Question 3}
On note $m(S)$ le nombre minimum de bocaux pour $S$ d\'ecigrammes de confiture et un tableau d capacit\'es $V$. On d\'efinit une famille de probl\`emes interm\'ediaires de la fa\c{c}on suivante : \'etant donn\'es un entier $s$ et un entier $i \in \{1, \dotsc, k\}$, on note $m(s,i)$ le nombre minimum de bocaux n\'ecessaires pour une quantit\'e totale $s$ en ne choisissant des bocaux que dans le syst\`eme de capacit\'es $V[1],V[2],\dotsc,V[i]$.

On pose :
\begin{align*}
 m(0,i) &= 0 & \forall & i \in \{1,\dotsc, k\} \\
 m(s,0) &= +\infty & \forall & s \geq 1 \\
 m(s,i) &= + \infty & \forall & i \in \{1,\dotsc,k\} \forall s < 0
\end{align*}

\begin{enumerate}[a)]
\item On a \( m(S) = m(S,k)\).
%\( m(S) = \displaystyle\min_{1 \leq i \leq k}{m(S,i)} \)

\item Soit la relation de r\'ecurrence suivante pour tout $ i \in \{1,\dotsc,k\} $
\[
m(s,i) = 
\begin{cases}
0 & \text{si } s = 0 \\
\min \{m(s,i-1),m(s-V[i],i)+1\} & \text{sinon}
\end{cases}
\]

\subsubsection*{Preuve}
Soit $s$ la capacit\'e de confiture \`a traiter. Deux cas sont possibles :\todo{r\'e currence double s, puis i}
\begin{enumerate}[i)]
 \item \underline{$s = 0$ :} Dans ce cas-l\`a, il n'y a pas de confiture \`a pr\'eserver. On n'utilise donc aucun bocal, i.e.\ on a $m(0,i) = 0$. \hfill\ensuremath{\blacksquare}
 \item \underline{$s \neq 0$ :} Puisque $m(s,i) = +\infty$ pour toute quantit\'e $s < 0$, la relation de r\'ecurrence ne concerne dans ce cas-l\`a que les quantit\'es $s > 0$. De m\^eme, on a $m(s,0) = +\infty$ pour toute quantit\'e $s \geq 1$. Donc, on ne consid\`ere que les $i > 0$.
 
\'Etant donn\'e le syst\`eme de capacit\'es $V[1], V[2], \dotsc, V[i]$, deux choix sont possibles : soit on utiilise des bocaux de capacit\'e $V[i]$, soit on ne s'en sert pas. 

D'un c\^ot\'e, le premier choix implique forc\'ement l'utilisation d'{\itshape au moins} un bocal de ladite capacit\'e. Ceci se traduit math\'ematiquement par $m(s-V[i],i)+1$. 

D'un autre c\^ot\'e, le deuxi\`eme choix rejete les bocaux de ladite capacit\'e. Donc, le r\'esultat est donn\'e par $m(s,i-1)$.

Comme on cherche \`a minimiser le nombre de bocaux \`a utiliser, $m(s,i)$ doit valoir le minimum entre ces deux r\'esultats. \hfill\ensuremath{\blacksquare}
\end{enumerate}
\end{enumerate}

\subsection*{Question 4}
Soit $M$ un tableau doublement indic\'e tel que la case $M[s,i]$, o\`u $s \in \{0,\dotsc,S\}$ et $i \in \{0,\dotsc,k\}$, contient la valeur $m(s,i)$.

\begin{enumerate}[a)]
 \item Soit le couple $(s,i) \in \{1,\dotsc,S\} \times \{1,\dotsc,k\}$. D'apr\`es la relation de r\'ecurrence prouv\'ee ci-dessus, pour calculer $m(s,i)$, on n\'ecessite des valeurs stock\'ees dans les cases $(s,i-1)$ et $(s-V[i],i)$, si $s-V[i] \geq 0$. Autrement dit, la case \`a gauche et toutes les cases au-dessus de $(s,i)$ doivent \^etre trait\'ees pr\'ealablement au calcul de la valeur de cette derni\`ere.
 
 Cela implique que le remplissage du tableau doit commencer \`a la case $(0,0)$ et aller jusqu'\`a la case $(S,k)$ en suivant un parcours matriciel. Cependant, ce parcours peut se faire par lignes ou par colonnes. 
 
 {\bfseries N.B.} Dans le cadre du projet, le parcours s\'equentiel des lignes a \'et\'e s\'electionn\'e.
 
 \item On d\'eduit des deux questions pr\'ec\'edentes un algorithme \texttt{AlgoProgDyn} qui pour un syst\`eme de $k$ capacit\'es $V[1],V[2],\dotsc,V[k]$ et une quantit\'e $S$ de confiture retourne $m(S)$. En voici le pseudocode :
 
\begin{algorithm}
\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{Main}{$k$: integer, $V$: $k$-integer array, $S$: integer}
    \State $M$: $S \times k$ integer matrix filled with $+\infty$
    \For{$s=0$ to $S$}
        \For{$i=0$ to $k$}
            \State $M[s][i] \gets $ \Call{GetMsi}{$V$, $M$, $s$, $i$}
        \EndFor
    \EndFor
    \State \Return $M[S][k]$\Comment{The value of $m(S)$}
\EndFunction
\Statex
\Function{GetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer matrix, $s$: integer, $i$: integer}
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \ElsIf {$M[s][i] < +\infty$}
    	\State \Return $M[s][i]$
    \Else 
        \State \Return $\min$(\Call{GetMsi}{$V$, $M$, $s$, $i-1$}, \Call{GetMsi}{$V$, $M$, $s-V[i]$, $i$} + 1)
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

 \item Pour l'analyse de la complexit\'e temporelle on utilise l'acc\`es \`a une case du tableau $M$ comme instruction \'el\'ementaire. Ainsi, on remarque que pour chaque case on acc\`ede au plus 3 fois \`a des \'el\'ements du tableau : l'une pour l'\'ecriture de la case et les deux restantes pour la lecture des cases dont on cherche le minimum des valeurs.
La complexit\'e temporelle de l'algorithme est donc en $\Theta(S\cdot k)$.

Quant \`a la complexit\'e spatiale, on se sert de deux structures de donn\'ees gourmandes, \`a savoir le tableau $V$ de $k$ cases d'entiers et la matrice $M$ de $S\cdot k$ cases d'entiers. En prenant comme taille de base celle d'un entier, on r\'ealise que la complexit\'e spatiale de l'algorithme est aussi en $\Theta(S\cdot k)$.
\end{enumerate}

\subsection*{Question 5}
On d\'esire \`a pr\'esent permettre \`a l'algorithme de retourner un tableau A indiquant le nombre de bocaux pris pour chaque type de capacit\'es.

\begin{enumerate}[a)]
 \item Dans un premier temps, on d\'ecide de placer dans chaque case du tableau $M[s,i]$, un tableau $A$ indiquant les bocaux pris pour la capacit\'e totale $s$ et des capacit\'es de bocaux prises parmi $V[1],\dotsc,V[i]$. 
 
 Pour ce faire, on effectue quelques modifications \`a l'algorithme \texttt{AlgoProgDyn}. Tout d'abord, la matrice $M$ devient une matrice de tableaux d'entiers d'ordre $S \times k$. \todo{Ce qui suit est faux} Puis l'affectation de la case $M[s][i]$ \`a la ligne 5 devient un appel \`a la proc\'edure \textproc{SetMsi}($V$, $M$, $s$, $i$). Cette derni\`ere reprend la logique de la fonction \textproc{GetMsi}, sauf que l'on cr\'ee le tableau $A$ pour la case correspondante au lieu renvoyer le nombre total de bocaux utilis\'es. 
 
 \begin{algorithm}
%\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Function{GetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \Else
        \State $A \gets M[s][i]$
        \State \Return $\sum_{j=1}^{i} A[j]$
    \EndIf
\EndFunction
\Statex
\Function{SetMsi}{$V$: $k$-integer array, $M$: $S \times k$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array filled with $i$ zeros
    \If {$s > 0$ \AND $i > 0$}
        \State $left \gets \Call{GetMsi}{V, M, s, i-1}$
        \State $up \gets \Call{GetMsi}{V, M, s-V[i], i}+1$
        \If {$left < up$}
            \State $A[1\dotsc i-1] \gets M[s][i-1]$
        \Else
            \State $A[1\dotsc i] \gets M[s-V[i]][i]$
            \State $A[i] \gets A[i] + 1$
        \EndIf
    \EndIf
    \State $M[s][i] \gets A$
\EndFunction
\end{algorithmic}
\end{algorithm}
 
 \item Dans un deuxi\`eme temps, on souhaite \'eviter de copier dans chaque case du tableau $M$, les tableaux $A$ des bocaux utilis\'es. Pour ce faire, on conserve l'algorithme initial et on reconstitue {\itshape a posteriori} le tableau $A$ de la solution optimale. Voici le pseudocode du deuxi\`eme algorithme :
 \begin{algorithm}
\caption{AlgoProgDynRet}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{ConfitureBackward}{$k$: integer, $V$: $k$-integer array, $S$: integer, $M$: $S \times k$ integer matrix}
    \State $A$: integer array fileld with $k$ zeros
    \State $s, i$: integers
    \State $s \gets S$
    \State $i \gets k$
    \While {$s \ne 0$}
        \If {$i > 0$ \AND $M[s][i] = M[s][i-1]$}
        \Comment {no more capacity $V[i]$}
            \State $i \gets i-1$
        \Else
        \Comment {$M[s][i] = M[s-V[i]][i] + 1$}
            \State $A[i] \gets A[i] + 1$
            \State $s \gets s - V[i]$
        \EndIf
    \EndWhile
    \State \Return $A$
\EndFunction
\end{algorithmic}
\end{algorithm}

%{\bfseries N.B.} Il est important de remarquer que, \'etant donn\'ee l'ordre des tests, cet algorithme privil\'egie la solution utilisant le plus grand nombre de bocaux de capacit\'es distinctes.
 
 Force est de constater que l'algorithme suit {\itshape dans le pire cas} un chemin de d\'eplacements unitaires dans le m\^eme sens de la case $(S,k)$ \`a la case $(0,0)$. C'est pourquoi on effectue {\itshape au plus} $S+k$ tours de boucle. On remarque aussi que le corps de la boucle comporte uniquement des instructions \'el\'ementaires. Ce morceau de l'algorithme est ainsi en $\BigO(S+k)$.
 
 Par ailleurs, l'initialisation du tableau $A$ est en $\Theta(k)$. On en d\'eduit que la compl\'exit\'e de l'algorithme de retour est en $\BigO(S+k)$. \todo{Complexit\'e totale ? que le retour ? spatiale ?}
\end{enumerate}

\section{Algorithme III : Cas particulier et algorithme glouton}

\subsection*{Question 7}
On utilisera un tableau \`a deux dimensions pour stocker les valeurs de \( E_{i,j} \). De plus, on consid\`erera que l'acc\`es \`a une case du tableau et l'appel \`a \texttt{e()} sont des instructions \'el\'ementaires  compte tenu de leur complexit\'e : $\Theta(1)$. 

Tout d'abord, on initialise la premi\`ere case de la premi\`ere ligne \`a 0. Donc, la complexit\'e de cette partie est en $\Theta(1)$. 

Puis, la premi\`ere boucle \texttt{for} est effectu\'ee \( n-1 \) fois et \`a chaque tour de boucle on ne r\'ealise que des {\itshape IE}. Donc, la complexit\'e de cette partie est en $\Theta(n)$. 

Finalement, on effectue deux boucles l'une \`a l'int\'erieur de l'autre. La boucle imbriqu\'ee consiste en le calcul du maximum de deux expressions. Les op\'erations arithm\'etiques n'\'etant pas d'instructions repr\'esentatives, la premi\`ere d'entre elles comprend deux {\itshape IE}. En ce qui concerne le deuxi\`eme argument, le nombre d'{\itshape IE} effectu\'ees est \( 2p \). Donc, le nombre d'{\itshape IE} r\'ealis\'ees dans cette partie est \( \\c = \sum_{p=1}^{n-1}\sum_{i=1}^{n-p}{2p+2} = \sum_{p=1}^{n-1}{(2p+2)(n-p)} = 2\sum_{p=1}^{n-1}{[p(n-1)+n-p^2]} \). D'o\`u, \( c = (n-1)^2n + 2(n-1)n - \dfrac{(n-1)n(2n-1)}{3} = \dfrac{(n-1)n(n+4)}{3} \). Donc, la complexit\'e de cette partie est en $\Theta(n^3)$.

De ces trois faits, on en d\'eduit que la complexit\'e de l'algorithme est en $\Theta(n^3)$.

\subsection*{Question 9}
\begin{itemize}[a)]
 \item Montrons qu'il existe un plus grand indice $j$ pris dans $\{1,\dotsc,k\}$ tel que $o_j < g_j$.
 
 D'apr\`es les conditions du probl\`eme, on sait que les solutions $g$ et $o$ sont diff\'erentes. Donc, il existe {\itshape au moins} un indice $j$ tel que $o_j < g_j$ car sinon la solution $g$ n'utiliserait toute la quantit\'e de confiture. Par ailleurs, on sait que $k$ est fini, d'o\`u il existe un plus grand indice $j$ pris dans $\{1,\dotsc,k\}$ remplissant ladite condition.
 
 \item Montrons que \( \displaystyle\sum_{i=1}^{j} V[i]\cdot g_i = \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i\).
 
 D'apr\'es la sous-question pr\'ec\'edente, on a $o_l \geq g_l$ pour tout $l$ dans $\{j+1,\dotsc, k\}$ et, plus exactement, $o_l = g_l$. En effet, il n'existe pas de $l_0 \in \{j+1,\dotsc, k\}$ tel que $o_l_0 > g_l_0$ et, puisque l'algorithme glouton choisit le nombre maximum possible de bocaux de capacit\'e $V[l_0]$, $o_l_0 \leq g_l_0$.
 
 Donc, on a \( \displaystyle\sum_{i=1}^{k} V[i]\cdot g_i = \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i\) et \( \displaystyle\sum_{i=j+1}^{k} V[i]\cdot g_i = \displaystyle\sum_{i=j+1}^{k} V[i]\cdot o_i\). De ces faits, \( \displaystyle\sum_{i=1}^{j} V[i]\cdot g_i = \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i\).
 
 \item Montrons que \( \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i \geq V[j]\).
 
 On sait que \( \displaystyle\sum_{i=1}^{j-1} V[i]\cdot g_i \geq 0\), d'o\`u \( V[j]\cdot g_j \leq \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i\). Donc, \( V[i]\cdot (g_i - o_i) \leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i\). Or $g_i - o_i \geq 1$ car ce sont des entiers naturels. Donc, \( V[j] \leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i\).
 
 \item D'apr\`es la sous-question pr\'ec\'edente, on a 
 \begin{alignat*}[1]
 	V[j] &\leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i \\
 		 &\leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot (d-1) \\
 		 &\leq (d-1)\cdot \displaystyle\sum_{i=1}^{j-1} 2^{i-1} \\
 		 &\leq (d-1)\cdot \frac{d^{j-1}-1}{d-1}
 	d^{j-1}	 &\leq d^{j-1}-1 & \text{car } d-1 \geq 1
 \end{alignat*}
 On arrive donc \`a une contradiction. 
 \item D'apr\`es les conditions du probl\`eme, on a \( V[l]\cdot d = V[l+1] \), d'o\`u \( 0 = -V[l]\cdot d + V[l+1] \).
 Donc, \( V[l]\cdot o_l + V[l+1]\cdot o_{l+1} = V[l]\cdot (o_l-d) + V[l+1]\cdot (o_{l+1} + 1)\), i.e.\ \( V[l]\cdot o_l + V[l+1]\cdot o_{l+1} = V[l]\cdot o_l' + V[l+1]\cdot o_{l+1}'\).
  
  Par ailleurs, on a $o_i' = o_i $ pour tout $i \in \{1, \dotsc, k\}\setminus \{ l,l+1 \}$. De ces faits, ( \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i' = \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i\), i.e.\ $o'$ est aussi une solution du probl\`eme. \todo{d\'eduire que Expo est glouton-compatible}
\end{itemize}

\subsection*{Question 10}
Montrons que tout syst\`eme de capacit\'es $V$ avec $k = 2$ est glouton-compatible.

On a montr\'e dans la question pr\'ec\'edente que le syst\`eme Expo est glouton-compatible.

Soit $V = [1, p]$, o\`u $p > 1$, un syst\`eme de capacit\'es. On remarque que ce syst\`eme est un syst\`eme Expo avec $k = 2$ et $d = p \geq 2$.

De ces faits, tout syst\`eme de capacit\'e $V$ avec $k = 2$ est bien glouton-compatible.

\newpage
\part{Mise en \oe uvre}

\section{Impl\'ementation}
Le but de ce second exercice est de mesurer de mani\`ere exp\'erimentale la complexit\'e de la fonction \texttt{tailleMaxRec} et de l'algorithme d\'ecrit dans la question 5 de l'exercice pr\'ec\'edent. Le choix du langage de programmation est libre. La complexit\'e exp\'erimentale de l'ex\'ecution d'une fonction correspond ici au temps qu'il faut pour que la fonction s'ex\'ecute.

Dans cet exercice, {\itshape n} d\'esigne la taille de la s\'equence initiale.

\subsection*{Question 3}
La plus grande valeur de $n$ que l'on peut traiter sans probl\`eme de m\'emoire ou de temps d'ex\'ecution de quelques minutes pour la fonction \texttt{tailleMaxRec} est 18. 

Quant \`a \texttt{tailleMaxIter}, la valeur de $n$ correspondante est 1600.

\subsection*{Question 4}
On a mis dans le tableau ci-dessous le temps d'ex\'ecution de plusieurs appels \`a la fonction \texttt{tailleMaxRec} selon les valeurs de $n$.
	\begin{center}
	\begin{tabular}{|c|cc|}
	\hline $n$ & $CRec(n)$ (en s.) & $\log CRec(n)$ \\
	\hline 11 &   0.0915572 & -1.0383075 \\ 
	\hline 12 &   0.3087260 & -0.5104268 \\ 
	\hline 13 &   0.9356748 & -0.0288751 \\ 
	\hline 14 &   3.0208589 &  0.4801304 \\
	\hline 15 &   9.7992974 &  0.9911949 \\ 
	\hline 16 &  30.8693360 &  1.4895273 \\ 
	\hline 17 & 100.5011405 &  2.0021710 \\
	\hline 18 & 322.5870859 &  2.5086470 \\
	\hline
	\end{tabular}
	\end{center}
	
	On en d\'eduit la droite de r\'egression de $\log CRec(n)$ en fonction de $n$ : $\\\Delta : y = 0.505452x - 6.592292$. On remarque que la pente de la droite est $0.505452$, ce qui \'etait attendu car la valeur est comprise entre $\log 2 = 0.301030$ et $\\\log 4 = 0.602060$. 
	%On remarque que la fonction $\log CRec(n)$ est lin\'eaire compte tenu que les points forment une droite dont la pente est $0.5108032$ et l'\'ecart type est $\sigma = 0.0075038$.

\newpage
\subsection*{Question 5}
On a mis dans le tableau ci-dessous le temps d'ex\'ecution de plusieurs appels \`a la fonction \texttt{tailleMaxIter} selon les valeurs de $n$.
	\begin{center}
	\begin{tabular}{|c|cc|}
	\hline $n$ & $CIter(n)$ (en s.) & $\dfrac{CIter(n)}{n^3}$ \\[6pt]
	\hline 200 & 0.5192115 & $\num{6.4901434E-08}$ \\ 
	\hline 400 & 4.1114257 & $\num{6.4241026E-08}$ \\ 
	\hline 600 & 14.2562266 & $\num{6.6001049E-08}$ \\ 
	\hline 800 & 34.8566699 & $\num{6.8079433E-08}$ \\
	\hline 1000 & 71.8084174 & $\num{7.1808417E-08}$ \\ 
	\hline 1200 & 124.3441816 & $\num{7.1958438E-08}$ \\ 
	\hline 1400 & 200.7089246 & $\num{7.3144652E-08}$ \\
	\hline 1600 & 314.0727653 & $\num{7.6677921E-08}$ \\
	\hline
	\end{tabular}
	\end{center}
	
	On en d\'eduit la droite de r\'egression de $\dfrac{CIter(n)}{n^3}$ en fonction de $n$ : $\\\Delta : y = \num{8.842541E-12}x - \num{6.164326E-08}$. On remarque l'ordre de grandeur de la pente de la droite : $\num{8.842541E-12} \ll 1$. Ceci implique que la fonction est bien constante de valeur $\num{6.9601546E-08}$. 
	%On remarque que la fonction $\dfrac{CIter(n)}{n^3}$ est constante compte tenu que les points forment la droite $\Delta : y = \num{7.3965667e-08}$ avec un \'ecart type ${\sigma = \num{5.8075249e-09}}$.

\newpage
\begin{appendices}
 \section{Suites croissantes}
 \label{appendix:suites}
 On rappelle la d\'efinition des suites $b(s)$ et $c(s)$ comme suit :
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      %2 & \text{si } s = 1 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 1 
   \end{cases} \right.
\end{equation*}

Montrons que les deux suites sont croissantes.

\subsection*{Suite $b(s)$}
Soit la propri\'et\'e suivante $Q_{1}(s), s \geq 0$ : $b(s) \leq b(s+1)$.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$

\subsubsection*{Preuve}
\underline{Base} : On a $b(0) = 0 \leq 2 = b(1) \leq 2\cdot 0 + 2 = b(2)$. 
Donc, la propri\'et\'e est v\'erifi\'ee aux rangs 0 et 1.

\medskip
\underline{Induction} : Supposons $Q_{1}(s-2)$ et $Q_{1}(s-1)$ vraies pour un $s \geq 2$ fix\'e. 
Montrons $Q_{1}(s)$ vraie.

\smallskip
Par hypoth\`ese de r\'ecurrence, $b(s-2) \leq b(s-1)$. D'o\`u, $2\cdot b(s-2)+2 \leq 2\cdot b(s-1)+2$.
Or, par d\'efinition, $b(s+1) = 2\cdot b(s-1) + 2$.
Donc, $b(s) \leq b(s+1)$, i.e.\ la propri\'et\'e est v\'erifi\'ee au rang $s$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{1}(0) \text{ et } Q_{1}(1) \text{ vraies } \\
\forall s \geq 2, [(Q_{1}(s-2) \text{ et } Q_{1}(s-1)) \Rightarrow Q_{1}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq b(s+1)
\end{array}\right .
\end{equation*}

On remarque que ceci correspond \`a la d\'efinition d'une suite croissante. \hfill\ensuremath{\blacksquare}

\subsection*{Suite $c(s)$}
Soit la propri\'et\'e suivante $Q_{2}(s), s \geq 0$ : $c(s) \geq 0$.
Montrons-la par r\'ecurrence faible sur $s$.

\subsubsection*{Preuve}
\underline{Base} : Pour $s = 0$, on a $c(0) = 0 \geq 0$. 
Donc, la propri\'et\'e est v\'erifi\'e aux rang 0.

\medskip
\underline{Induction} : Supposons $Q_{2}(s)$ vraie pour un $s \geq 0$ fix\'e. 
Montrons $Q_{2}(s+1)$ vraie.

\smallskip
Par d\'efinition, $c(s+1) = 2\cdot c(s) + 2$.
Or, par hypoth\`ese de r\'ecurrence, $c(s) \geq 0$. D'o\`u, $2\cdot c(s)+2 \geq 2$.
Donc, $c(s+1) \geq 2 \geq 0$. On en d\'eduit par transitivit\'e que la propri\'et\'e est v\'erifi\'ee au rang $s+1$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{2}(0) \text{ vraie } \\
\forall s \geq 0, [Q_{2}(s) \Rightarrow Q_{2}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) \geq 0
\end{array}\right .
\end{equation*}

Par ailleurs, on a $c(s) = 2\cdot c(s-1) + 2, s \geq 1$. D'o\`u, $c(s) \geq 2\cdot c(s-1)$.
Comme cette suite est positive, on sait que $2\cdot c(s-1) \geq c(s)$. Donc, par transitivit\'e, $c(s) \geq c(s-1)$. Autrement dit, pour tout $s \geq 0$, $c(s+1) \geq c(s)$. 
\hfill\ensuremath{\blacksquare}

\newpage
\section{Complexit\'e de \texttt{RechercheExhaustive} dans le cas g\'en\'eral}

\end{appendices}
	
\printindex
\end{document}



