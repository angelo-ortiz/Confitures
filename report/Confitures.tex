\documentclass[12pt,a4paper]{article}

%########################### Preferences #################################


% ******** vmargin settings *********
\usepackage{vmargin} %This give you full control over the used page arae, it maybe not the idea od Latex to do so, but I wanted to reduce to amount of white space on the page
\setpapersize{A4}
\setmargins{3cm}%			%linker Rand, left edge
					 {1.5cm}%     %oberer Rand, top edge
           {14.7cm}%		%Textbreite, text width
           {23.42cm}%   %Texthoehe, text hight
           {14pt}%			%Kopfzeilenhöhe, header hight
           {1cm}%   	  %Kopfzeilenabstand, header distance
           {0pt}%				%Fußzeilenhoehe footer hight
           {2cm}%    	  %Fusszeilenabstand, footer distance

% ********* Font definiton ************
\usepackage{t1enc} % as usual
\usepackage[utf8]{inputenc} % as usual
\usepackage[french]{babel}
\usepackage{makeidx}
\usepackage[titletoc]{appendix}
\usepackage[shortlabels]{enumitem} 
\usepackage{siunitx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{listingsutf8}
\usepackage{csquotes}
\usepackage[table]{xcolor}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{xparse}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{mathtools, stmaryrd}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage[justification=centering]{caption}
\usepackage{multirow}
\usepackage[pdftex]{graphicx} % required to import graphic files
\usepackage{tikz}
\usetikzlibrary{datavisualization}
\usetikzlibrary{babel}
\usepackage{pgfplots}
\pgfplotsset{compat=1.13}
\usetikzlibrary{plotmarks}

% ********* Graphics definition *******
\usepackage{eso-pic} % these two are required to add the little picture on top of every page
\usepackage{everyshi} % these two are required to add the little picture on top of every page
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\DeclarePairedDelimiterX{\Iintv}[1]{\llbracket}{\rrbracket}{\iintvargs{#1}}
\NewDocumentCommand{\iintvargs}{>{\SplitArgument{1}{,}}m} {\iintvargsaux#1}
\NewDocumentCommand{\iintvargsaux}{mm} {#1\mkern1.5mu..\mkern1.5mu#2}
\renewcommand{\arraystretch}{1.2}
\algnewcommand\AND{\textbf{and}\xspace}
\algnewcommand\OR{\textbf{or}\xspace}
\newcommand{\BigO}{\mathcal{O}}
\newcommand{\tdots}{\mathinner {\ldotp \ldotp}}
\renewcommand{\appendixname}{Annexe}
\hypersetup{
    colorlinks  = true,
    linkcolor   = black,
    citecolor   = blue,
    urlcolor    = blue,
    linktocpage = false
}

\pagestyle{plain} % on headers or footers on the first page

\makeindex
\begin{document}

\begin{titlepage}
	\centering
	\includegraphics[width=0.30\textwidth]{../img/logo.jpg}\par\vspace{1cm}
	{\scshape\LARGE Sorbonne Universit\'e \par}
	\vspace{1cm}
	{\scshape\Large 3I003 : Algorithmique\par}
	\vspace{1.5cm}
	{\Large \bfseries Projet :\par}
	{\huge\bfseries Confitures\par}
	\vspace{2cm}
	{\Large\itshape Ahmed Boukerram \par Angelo Ortiz\par}
	
	\vfill

% Bottom of the page
	{\large Licence d'Informatique\par}
	{\large Ann\'ee 2018/2019\par}
\end{titlepage}

%\newpage

%%The following loads the picture on top of every page, the numbers in \put() define the position on the page:
%\AddToShipoutPicture{\setlength\unitlength{0.1mm}\put(604,2522){\includegraphics[width=1.5cm]{logo.jpg}}}

%\pagestyle{cb} % now we want to have headers and footers

\tableofcontents
\listoffigures
\listoftables

\newpage

\part*{Introduction}
\addcontentsline{toc}{part}{Introduction}

Sur un forum de cuisine, on pourrait trouver une question portant sur le nombre minimal de pots n\'ecessaires pour la pr\'eservation d'une certaine quantit\'e de confiture pr\'epar\'ee. Il est important de remplir au complet chaque bocal afin de prolonger au maximum le temps de conservation du produit. Mais la capacit\'e des bocaux n'est pas la m\^eme pour tous. C'est pourquoi on veut proposer des algorithmes r\'esolvant cette question : on se fixe pour objectif d'utiliser le moins possible de bocaux.

Pour d\'efinir ce probl\`eme, on dispose des donn\'ees suivantes. Il y a $S$ d\'ecigrammes de confiture que l'on doit verser dans des bocaux vides. On compte aussi plusieurs bocaux de diverses capacit\'es que l'on range en $k$ classes : chaque classe de bocal correspond \`a une capacit\'e distincte. On appellera {\itshape syst\`eme de capacit\'es} l'ensemble des capacit\'es dont on dispose. On note ces $k$ capacit\'es par un tableau $V$ de taille $k$ num\'erot\'e par ordre croissant :
\begin{itemize}[\textbullet]
 \item $V[1] < V[2] < \cdots < V[k]$ ; et
 \item chaque capacit\'e $V[i]$ est exprim\'ee par la quantit\'e en d\'ecigrammes que l'on peut mettre dans un bocal.
\end{itemize}

\smallskip
On se fixe aussi certaines contraintes qui garantissent l'existence d'une solution au probl\`eme :
\begin{itemize}[\textbullet]
 \item la quantit\'e $S$ est un nombre entier de d\'ecigrammes ;
 \item la capacit\'e minimal d'un bocal est 1 d\'ecigramme, i.e.\ $V[1] = 1$ ; et
 \item on dispose d'une tr\`es grande quantit\'e (suppos\'ee ainsi illimit\'ee) de bocaux de chacune des capacit\'es.
\end{itemize}
En effet, en tenant compte des trois hypoth\`eses, on remarque que l'on peut toujours verser la totalit\'e de confiture dans des pots de 1 d\'ecigramme.

\bigskip
Notre objectif est de remplir le moins possible de bocaux et qu'ils soient tous remplis exactement \`a sa capacit\'e maximale. Ainsi, \'etant donn\'es :
\begin{itemize}
 \item un syst\`eme de $k$ capacit\'es $V[i] \in \mathbb{N}$, $i \in \{1,\dotsc,k\}$, avec $V[1]=1$,
 \item et une quantit\'e totale $S \in \mathbb{N}$ de confiture,
\end{itemize}
le but est de d\'eterminer le nombre minimum de bocaux tels que la somme de leurs capacit\'es est \'egale \`a $S$. On cherche donc \`a retourner un couple $(n,A)$, o\`u $n$ est le nombre de bocaux utilis\'es et $A$ est un tableau de taille $k$ tel que $A[i]$ repr\'esente le nombre de bocaux de capacit\'e $V[i]$ \`a remplir au complet. On a ainsi que $n = \sum_{i=1}^{k} A[i]$.

\bigskip
Les objectifs de ce projet sont l'analyse th\'eorique et la mise en \oe uvre de trois algorithmes r\'esolvant le probl\`eme d\'ecrit ci-dessus. Dans un premier temps, on formalise le probl\`eme et propose plusieurs algorithmes dont on fera l'analyse de complexit\'e. Dans un deuxi\`eme temps, on impl\'emente ces algorithmes au moyen du langage de programmation Python afin de v\'erifier exp\'erimentalement les complexit\'es trouv\'ees pr\'ec\'edemment.

\newpage
\part{Partie th\'eorique}

\section{Algorithme I : Recherche exhaustive}

\subsection*{Question 1}
Soit la propri\'et\'e suivante \( P_{1}(s), s \in \mathbb{Z} : \) \texttt{RechercheExhaustive}$(k,V,s)$ se termine et renvoie le nombre minimal de bocaux \`a remplir pour une quantit\'e $s$ de confiture avec un syst\`eme de $k$ capacit\'es d\'ecrit dans les cases du tableau $V[1 \tdots k]$.
Montrons-la par r\'ecurrence forte sur $s$.

\subsubsection*{Preuve}
\underline{Cas n\'egatif} : Pour $s < 0$, la quantit\'e de confiture est n\'egative. Dans ce cas, on ne peut pas remplir les bocaux et on dit que le nombre de bocaux est infini. 
Par ailleurs, dans le corps de l'algorithme, on rentre dans le bloc \texttt{then} du premier branchement conditionnel et renvoie bien $+\infty$. De plus, on n'a effectu\'e que des instructions \'el\'ementaires en nombre fini.
De ces faits, \texttt{RechercheExhaustive} est valide et se termine dans le cas n\'egatif.

\medskip
\underline{Base} : Pour \( s = 0\), la quantit\'e de confiture est nulle. Aussi, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{then} du deuxi\`eme branchement conditionnel. Donc, on renvoie $0$, ce qui est correct puisque aucun bocal ne doit \^etre rempli.

De la m\^eme mani\`ere que dans le cas o\`u $s<0$, on montre ici que l'algorithme se termine car la suite d'instructions effectu\'ees ne comporte que des instructions \'el\'ementaires.
De ces faits, $P_{1}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{1}(s) \) vraie pour tout \( s < s_0 \), pour un $s_0>0$ fix\'e. Montrons \( P_{1}(s_0) \) vraie.

Comme la quantit\'e de confiture $s_0$ est positive, on a besoin d'{\itshape au moins} un bocal o\`u la verser. On remarque qu'il n'y a pas de contrainte sur ce premier bocal. Pour s'assurer de bien calculer le nombre minimum de bocaux \`a remplir, on essaie donc toutes les capacit\'es possibles pour le premier bocal, puis on r\'esout le probl\`eme r\'ecursif induit par chacune d'entre elles. De cette mani\`ere il suffit de choisir la configuration optimale parmi les $k$ possibles.

Par ailleurs, en ce qui concerne l'algorithme \texttt{RechercheExhaustive}, on rentre dans le bloc \texttt{else} du premier branchement conditionnel, puis dans le bloc \texttt{else} du deuxi\`eme branchement conditionnel, puisque $s_0 > 0$. On sait que la capacit\'e minimum est 1 \si{dg}. On en d\'eduit que le nombre {\itshape maximum} de bocaux \`a utiliser est $s_0$. 

On cherche \`a am\'eliorer la solution de d\'epart. Pour ce faire, on teste chaque capacit\'e $V[i], i \in \{1, \dotsc, k \}$, pour le premier bocal \`a remplir. Il reste ainsi $s_0-V[i]$ d\'ecigrammes de confiture \`a verser. D'apr\`es les conditions du probl\`eme, $V[i] \geq 1$, d'o\`u $s_0-V[i] < s_0$. Par hyporh\`ese de r\'ecurrence, \texttt{RechercheExhaustive}$(k,V,s)$, o\`u $s=s_0-V[i]$, se termine et est valide. On rajoute 1 \`a cette solution en raison du premier choix. On teste ensuite si cette solution am\'eliore la solution courante et, le cas \'ech\'eant, on la met \`a jour. On r\'ep\`ete ce proc\'ed\'e pour chacune des capacit\'es du tableau $V[1 \tdots k]$. 

Comme mentionn\'e pr\'ec\'edemment, \`a la fin de l'examen des $k$ capacit\'es pour le premier bocal, on se retrouve avec la solution optimale. 
\'Etant donn\'e que l'appel \texttt{RechercheExhaustive}$(k, V, s_0)$ renvoie cette solution optimale, il est valide. 
Par ailleurs, par hypoth\`eses de r\'ecurrence, les appels r\'ecursifs se terminent. On effectue $k$ tours de boucle du bloc \texttt{for} qui contient ces appels r\'ecursifs et quelques instructions \'el\'ementaires de plus.
On en d\'eduit que \texttt{RechercheExhaustive}$(k, V, s_0)$ se termine.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
\forall s < 0, P_{1}(s) \text{ vraie } \\
P_{1}(0) \text{ vraie } \\
\forall s_0 > 0, [(\forall s < s_0, P_{1}(s)) \Rightarrow P_{1}(s_0) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{Z}, \texttt{RechercheExhaustive}(k,V,s) \\
\text{se termine et est valide.}
\end{array}\right .
\end{equation*}
 
\subsubsection*{Cas particulier}
D'apr\`es le r\'esultat pr\'ec\'edant, pour $s = S \in \mathbb{N}$ (la quantit\'e de confiture dans le cadre de ce projet), on a que l'algorithme est valide et se termine lorsqu'il est appel\'e par l'appel initial \texttt{RechercheExhaustive}$(k,V,S)$. 

\subsection*{Question 2}
Soient $b(s)$ et $c(s)$ les suites d\'efinies par
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 1 
   \end{cases} \right.
\end{equation*}

Supposons que les seules capacit\'es de bocal disponibles soient 1 \si{dg} et 2 \si{dg}. Soit $a(s)$ le nombre d'appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$.

\begin{enumerate}[a)]
\item La suite $a(s)$ est d\'efinie par
\[ a(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      a(s-2) + a(s-1) + 2 & \text{si } s\geq 2 
   \end{cases}
\]

\item Soit la propri\'ete suivante $P_{2}(s), s\geq 0$: $ b(s) \leq a(s) \leq c(s) $.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$. 

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $b(0) = a(0) = c(0) = 0 $. Donc, $P_{2}(0)$ est vraie.

Pour \( s = 1\), on a $b(1) = a(1) = c(1) = 2 $. Donc, $P_{2}(1)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{2}(s-2) \) et \( P_{2}(s-1) \) vraies pour un \( s \geq 2 \) fix\'e. Montrons \( P_{2}(s) \) vraie.

D'apr\`es les hypoth\`eses de r\'ecurrence, on a : 
\begin{alignat}{1}
b(s-2) &\leq a(s-2) \leq c(s-2) \label{eq:hyp_2b1}\\
b(s-1) &\leq a(s-1) \leq c(s-1) \label{eq:hyp_2b2}
\end{alignat} 

Par d\'efinition de ces suites r\'ecursives, on a :
\begin{alignat}{1}
b(s) &= 2\cdot b(s-2) + 2 \label{eq:def_2b1}\\
a(s) &= a(s-2) + a(s-1) + 2 \label{eq:def_2b2}\\
c(s) &= 2\cdot c(s-1) + 2 \label{eq:def_2b3}
\end{alignat}

\'Etant donn\'e que les suites $b(s)$ et $c(s)$ sont croissantes (c.f.\ annexe \hyperref[appendix:suites]{\textcolor{red}{A}}), les in\'egalit\'es \eqref{eq:hyp_2b1} et \eqref{eq:hyp_2b2} deviennent respectivement
\begin{alignat*}{1}
b(s-2) &\leq a(s-2) \leq c(s-1) \\
b(s-2) &\leq a(s-1) \leq c(s-1)
\end{alignat*}

Il en r\'esulte que 
\begin{alignat}{1}
2\cdot b(s-2) + 2 &\leq a(s-2) + a(s-1) + 2 \leq 2\cdot c(s-1) + 2 \label{eq:ineg_2b}
\end{alignat}

En rempla\c{c}ant les expressions \eqref{eq:def_2b1}, \eqref{eq:def_2b2} et \eqref{eq:def_2b3} en \eqref{eq:ineg_2b}, on obtient les in\'egalit\'es cherch\'ees : 
$ b(s) \leq a(s) \leq c(s) $.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{2}(0) \text{ et } P_{2}(1) \text{ vraies } \\
\forall s \geq 2, [(P_{2}(s-2) \text{ et } P_{2}(s-1)) \Rightarrow P_{2}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq a(s) \leq c(s)
\end{array}\right .
\end{equation*}

\item Soit la propri\'ete suivante \( P_{3}(s) \), $s \geq 0$ : $c(s) = 2^{s+1} - 2$.
Montrons-la par r\'ecurrence faible sur s.

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $c(0) = 0 $. De plus, $ 2^{0+1} - 2 = 2^1 - 2 = 0$. Donc, $P_{3}(0)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{3}(s) \) vraie pour un \( s \geq 0 \) fix\'e. Montrons \( P_{3}(s+1) \) vraie.

On a $ s+1 \geq 1 $. 

Par d\'efinition, 
\begin{equation}
    c(s+1) = 2\cdot c(s) + 2 \label{eq:def_2c} 
 \end{equation}

Or, par hypoth\`ese de r\'ecurrence, 
\begin{equation}
    c(s) = 2^{s+1} - 2 \label{eq:hyp_2c}
 \end{equation}

En rempla\c{c}ant \eqref{eq:hyp_2c} en \eqref{eq:def_2c}, on obtient
\begin{equation*}
    c(s+1) = 2 \cdot (2^{s+1} - 2) + 2 = 2^{s+2} - 2
 \end{equation*}

D'o\`u, $P_{3}(s+1)$ est vraie.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{3}(0) \text{ vraie } \\
\forall s \geq 0, [P_{3}(s) \Rightarrow P_{3}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) = 2^{s+1} - 2
\end{array}\right .
\end{equation*}

\item Soit la propri\'ete suivante \( P_{4}(s) \), $s \geq 0$ : $b(s) = c(\lceil \frac{s}{2} \rceil)$.
Montrons-la par r\'ecurrence d'ordre 2 sur s.

\subsubsection*{Preuve}
\underline{Base} : Pour \( s = 0\), on a $b(0) = 0 = c(\lceil \frac{0}{2} \rceil)$. Donc, $P_{4}(0)$ est vraie.

Pour \( s = 1\), on a $b(1) = 2 = 2\cdot 0 + 2 = c(\lceil \frac{1}{2} \rceil)$. Donc, $P_{4}(1)$ est vraie.

\medskip
\underline{Induction} : Supposons \( P_{4}(s-2) \) et \( P_{4}(s-1) \) vraies pour un \( s \geq 2 \) fix\'e. Montrons \( P_{4}(s) \) vraie.

On a $s \geq 2$ et $\lceil \frac{s}{2} \rceil \geq 1$.

Par d\'efinition, 
\begin{alignat}{1}
    b(s) &= 2\cdot b(s-2) + 2 \label{eq:def_2d1} \\
    c\left(\left\lceil \dfrac{s}{2} \right\rceil\right) &= 2\cdot c\left(\left\lceil \dfrac{s}{2} \right\rceil - 1\right) + 2 \label{eq:def_2d2}
\end{alignat}

Or, par hypoth\`ese de r\'ecurrence, 
\begin{equation}
 b(s-2) = c\left(\left\lceil \dfrac{s-2}{2} \right\rceil\right) \label{eq:hyp_2d}
\end{equation}
 
En rempla\c{c}ant \eqref{eq:hyp_2d} en \eqref{eq:def_2d1}, on obtient 
\begin{equation}
 b(s) = 2\cdot c\left(\left\lceil \dfrac{s}{2} -1 \right\rceil\right)+2\label{eq:egal_2d1}
\end{equation}

De plus, on sait que
\begin{equation*}
 \forall x \in \mathbb{R}, \forall p \in \mathbb{Z}, \lceil x + p \rceil = \lceil x \rceil + p 
\end{equation*}

En particulier, pour \eqref{eq:egal_2d1} on a 
\begin{equation}
 b(s) = 2\cdot c\left(\left\lceil \dfrac{s}{2} \right\rceil -1\right)+2\label{eq:egal_2d2}
\end{equation}

Par transitivit\'e entre \eqref{eq:def_2d2} et \eqref{eq:egal_2d2}, on obtient bien $b(s) = c(\lceil \frac{s}{2}\rceil)$. 

De ce fait, $P_{4}(s)$ est vraie.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
P_{4}(0) \text{ et } P_{4}(1) \text{ vraies } \\
\forall s \geq 2, [(P_{4}(s-2) \text{ et } P_{4}(s-1)) \Rightarrow P_{4}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) = c(\lceil \frac{s}{2}\rceil)
\end{array}\right .
\end{equation*}

\item On d\'eduit des deux questions pr\'ec\'edentes que 
\begin{equation*}
 b(s) = 2^{\lceil \frac{s}{2} \rceil + 1} - 2
\end{equation*}


D'apr\`es la question b), on a $ b(s) \leq a(s) \leq c(s) $. 

De ces faits, 
\begin{equation*}
 2^{\lceil \frac{s}{2} \rceil + 1} - 2 \leq a(s) \leq 2^{s+1} - 2
\end{equation*}


Pour le calcul de la complexit\'e temporelle de l'algorithme, consid\'erons seulement les appels r\'ecursifs effectu\'es par \texttt{RechercheExhaustive}$(2,[1,2],s)$.
La complexit\'e pour ce syst\`eme de deux capacit\'es est donn\'ee par $a(S)$. La complexit\'e est ainsi en $\Omega\left(\sqrt{2}^S\right)$ et $\mathcal{O}(2^S)$.

{\bfseries N.B.} Pour la complexit\'e de cet algorithme dans le cas g\'en\'eral, regardez l'annexe \hyperref[appendix:rech_gen]{\textcolor{red}{B}}.

\end{enumerate}

\newpage
\section{Algorithme II : Programmation dynamique}

\subsection*{Question 3}
On note $m(S)$ le nombre minimum de bocaux pour $S$ d\'ecigrammes de confiture et un tableau de capacit\'es $V$. On d\'efinit une famille de probl\`emes interm\'ediaires de la fa\c{c}on suivante : \'etant donn\'es un entier $s$ et un entier $i \in \{1, \dotsc, k\}$, on note $m(s,i)$ le nombre minimum de bocaux n\'ecessaires pour une quantit\'e totale $s$ en ne choisissant des bocaux que dans le syst\`eme de capacit\'es $V[1],V[2],\dotsc,V[i]$.

On pose :
\begin{align*}
 m(0,i) &= 0 & \forall & i \in \{1,\dotsc, k\} \\
 m(s,0) &= +\infty & \forall & s \geq 1 \\
 m(s,i) &= + \infty & \forall & i \in \{1,\dotsc,k\} \text{ }\forall s < 0
\end{align*}

\begin{enumerate}[a)]
\item On a \( m(S) = m(S,k)\).
%\( m(S) = \displaystyle\min_{1 \leq i \leq k}{m(S,i)} \)

\item Soit la relation de r\'ecurrence suivante pour tout $ i \in \{1,\dotsc,k\} $
\[
m(s,i) = 
\begin{cases}
0 & \text{si } s = 0 \\
\min \{m(s,i-1),m(s-V[i],i)+1\} & \text{sinon}
\end{cases}
\]

Montrons-la par r\'ecurrence.

\subsubsection*{Preuve}
Soit $s$ la capacit\'e de confiture \`a traiter. Deux cas sont possibles :
\begin{enumerate}[i)]
 \item \underline{$s = 0$ :} Dans ce cas, il n'y a pas de confiture \`a pr\'eserver. On n'utilise donc aucun bocal, i.e.\ on a $m(0,i) = 0$. \hfill\ensuremath{\blacksquare}
 \item \underline{$s \neq 0$ :} Puisque $m(s,i) = +\infty$ pour toute quantit\'e $s < 0$, la relation de r\'ecurrence ne concerne dans ce cas que les quantit\'es $s > 0$. De m\^eme, on a $m(s,0) = +\infty$ pour toute quantit\'e $s \geq 1$. Donc, on ne consid\`ere que les $i > 0$.
 
\'Etant donn\'e le syst\`eme de capacit\'es $V[1], V[2], \dotsc, V[i]$, deux choix sont possibles : soit on utilise des bocaux de capacit\'e $V[i]$, soit on ne s'en sert plus. 

D'un c\^ot\'e, le premier choix implique forc\'ement l'utilisation d'{\itshape au moins} un bocal de ladite capacit\'e. Ceci se traduit math\'ematiquement par $m(s-V[i],i)+1$. 

D'un autre c\^ot\'e, le deuxi\`eme choix rejete les bocaux de ladite capacit\'e. Donc, le r\'esultat est donn\'e par $m(s,i-1)$.

Comme on cherche \`a minimiser le nombre de bocaux \`a utiliser, $m(s,i)$ doit valoir le minimum entre ces deux r\'esultats. \hfill\ensuremath{\blacksquare}
\end{enumerate}
\end{enumerate}

\subsection*{Question 4}
Soit $M$ un tableau doublement indic\'e tel que la case $M[s,i]$, o\`u $s \in \{0,\dotsc,S\}$ et $i \in \{0,\dotsc,k\}$, contient la valeur $m(s,i)$.

\begin{enumerate}[a)]
 \item Soit le couple $(s,i) \in \{1,\dotsc,S\} \times \{1,\dotsc,k\}$. D'apr\`es la relation de r\'ecurrence prouv\'ee ci-dessus, pour calculer $m(s,i)$, on a besoin des valeurs stock\'ees dans les cases $(s,i-1)$ et $(s-V[i],i)$, si $s-V[i] \geq 0$. Autrement dit, la case \`a gauche et toutes les cases au-dessus de $(s,i)$ doivent \^etre trait\'ees pr\'ealablement au calcul de la valeur de cette derni\`ere.
 
 Cela implique que le remplissage du tableau doit commencer \`a la case $(0,0)$ et aller jusqu'\`a la case $(S,k)$ en suivant un parcours matriciel. Ce parcours peut donc se faire soit par lignes, soit par colonnes. 
 
 {\bfseries N.B.} Dans le cadre du projet, on a s\'electionn\'e le parcours s\'equentiel des lignes.
 
 \item On d\'eduit des deux questions pr\'ec\'edentes un algorithme \texttt{AlgoProgDyn} qui pour un syst\`eme de $k$ capacit\'es $V[1],V[2],\dotsc,V[k]$ et une quantit\'e $S$ de confiture retourne $m(S)$. En voici le pseudo-code :
 
\begin{algorithm}
\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{ConfitureForwards}{$k$: integer, $V$: $k$-integer array, $S$: integer}
    \State $M$: $(S+1) \times (k+1)$ integer matrix filled with $+\infty$
    \For{$s=0$ to $S$}
        \For{$i=0$ to $k$}
            \State $M[s][i] \gets $ \Call{GetMsi}{$V$, $M$, $s$, $i$}
        \EndFor
    \EndFor
    \State \Return $M[S][k]$\Comment{the value of $m(S)$}
\EndFunction
\Statex
\Function{GetMsi}{$V$: $k$-integer array, $M$: $(S+1) \times (k+1)$ integer matrix, $s$: integer, $i$: integer}
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \ElsIf {$M[s][i] < +\infty$}\Comment{$M[s][i]$ already calculated}
    	\State \Return $M[s][i]$
    \Else 
        \State \Return $\min$(\Call{GetMsi}{$V$, $M$, $s$, $i-1$}, \Call{GetMsi}{$V$, $M$, $s-V[i]$, $i$} + 1)
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

 \item Pour l'analyse de la complexit\'e temporelle on utilise l'acc\`es \`a une case de la matrice $M$ comme instruction \'el\'ementaire. Ainsi, on remarque que pour chacune des $(S+1)\cdot (k+1)$ it\'erations de la boucle interne on acc\`ede au plus 5 fois \`a des \'el\'ements du tableau : l'une pour l'\'ecriture de la case et les quatre restantes pour les lectures des cases dont on cherche le minimum des valeurs. Par ailleurs, la cr\'eation et l'initialisation de la matrice $M$ se font en $\Theta(S\cdot k)$.
Donc, la complexit\'e temporelle de l'algorithme est en $\Theta(S\cdot k)$.

Quant \`a la complexit\'e spatiale, on se sert de deux structures de donn\'ees gourmandes, \`a savoir le tableau $V$ de $k$ cases d'entiers et la matrice $M$ de $(S+1)\cdot (k+1)$ cases d'entiers. En prenant comme taille de base celle d'un entier, on r\'ealise que la complexit\'e spatiale de l'algorithme est aussi en $\Theta(S\cdot k)$.
\end{enumerate}

\subsection*{Question 5}
On d\'esire \`a pr\'esent permettre \`a l'algorithme de retourner un tableau A indiquant le nombre de bocaux pris pour chaque type de capacit\'es.

\begin{enumerate}[a)]
 \item Dans un premier temps, on d\'ecide de placer dans chaque case du tableau $M[s,i]$, un tableau $A$ indiquant les bocaux pris pour la capacit\'e totale $s$ et des capacit\'es de bocaux prises parmi $V[1],\dotsc,V[i]$. 
 
 Pour ce faire, on effectue quelques modifications \`a l'algorithme \texttt{AlgoProgDyn}. Tout d'abord, la matrice $M$ devient une matrice de tableaux d'entiers d'ordre $(S+1) \times (k+1)$. De plus, la fonction \textproc{GetMsi} est modifi\'ee de sorte \`a utiliser le tableau de bocaux utilis\'es pour chaque case de la matrice lorsque n\'ecessaire. Finalement, on remplace l'appel \`a  \textproc{GetMsi} par un appel \`a \textproc{GetA} \`a la ligne 5 de l'algorithme initial. Cette nouvelle fonction reprend la logique de la fonction \textproc{GetMsi} initiale, sauf que l'on renvoie le tableau $A$ correspondant au lieu du nombre total de bocaux utilis\'es. 
 
 Voici le pseudo-code des modifications effectu\'ees :
 
\clearpage
\begin{algorithm}
%\caption{AlgoProgDyn}
\begin{algorithmic}[1]
\Function{GetMsi}{$V$: $k$-integer array, $M$: $(S+1) \times (k+1)$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array
    \If {$s = 0$} 
        \State \Return 0
    \ElsIf {$s < 0$} 
        \State \Return $+\infty$
    \ElsIf {$i = 0$} 
        \State \Return $+\infty$
    \Else
        \State $A \gets M[s][i]$
        \State \Return $\sum_{j=1}^{i} A[j]$
    \EndIf
\EndFunction
\Statex
\Function{GetA}{$V$: $k$-integer array, $M$: $(S+1) \times (k+1)$ integer array matrix, $s$: integer, $i$: integer}
    \State $A$: integer array filled with $i$ zeros
    \If {$s > 0$ \AND $i > 0$}
        \State $left \gets \Call{GetMsi}{V, M, s, i-1}$
        \State $up \gets \Call{GetMsi}{V, M, s-V[i], i}+1$
        \If {$left < up$}
            \State $A[1 \tdots i-1] \gets M[s][i-1]$
        \Else
            \State $A[1 \tdots i] \gets M[s-V[i]][i]$
            \State $A[i] \gets A[i] + 1$
        \EndIf
    \EndIf
    \State \Return $A$
\EndFunction
\end{algorithmic}
\end{algorithm}

En termes de m\'emoire, chaque case $M[s][i]$, o\`u $i > 0$ contient maintenant un tableau \`a $i$ cases d'entier. Ainsi, on a $\frac{k\cdot (k+1)}{2}$ cases d'entier dans chaque ligne, i.e.\ il y a $(S+1)\cdot \frac{k\cdot (k+1)}{2}$ cases d'entier dans toute la matrice $M$. De ce fait, la complexit\'e spatiale de cet algorithme est en $\Theta(S\cdot k^2)$.
 
 \item Dans un deuxi\`eme temps, on souhaite \'eviter de copier dans chaque case du tableau $M$, les tableaux $A$ des bocaux utilis\'es. Pour ce faire, on conserve l'algorithme initial et on reconstitue {\itshape a posteriori} le tableau $A$ de la solution optimale. Voici le pseudo-code du deuxi\`eme algorithme :
 
 \clearpage
 \begin{algorithm}
\caption{AlgoProgDynRet}
\begin{algorithmic}[1]
\Require $k \geq 0$ \AND $S \geq 0$
\Function{ConfitureBackwards}{$k$: integer, $V$: $k$-integer array, $S$: integer, $M$: $(S+1) \times (k+1)$ integer matrix}
    \State $A$: integer array filled with $k$ zeros
    \State $s, i$: integers
    \State $s \gets S$
    \State $i \gets k$
    \While {$s \ne 0$}
        \If {$i > 0$ \AND $M[s][i] = M[s][i-1]$}
        \Comment {no more $V[i]$-capacity jars}
            \State $i \gets i-1$
        \Else
        \Comment {$M[s][i] = M[s-V[i]][i] + 1$}
            \State $A[i] \gets A[i] + 1$
            \State $s \gets s - V[i]$
        \EndIf
    \EndWhile
    \State \Return $A$
\EndFunction
\end{algorithmic}
\end{algorithm}

%{\bfseries N.B.} Il est important de remarquer que, \'etant donn\'ee l'ordre des tests, cet algorithme privil\'egie la solution utilisant le plus grand nombre de bocaux de capacit\'es distinctes.
 
 Force est de constater que l'algorithme suit {\itshape dans le pire cas} un chemin de d\'eplacements unitaires sans detours de la case $(S,k)$ \`a la case $(0,0)$. C'est pourquoi on effectue {\itshape au plus} $S+k$ tours de boucle. On remarque aussi que le corps de la boucle comporte uniquement des instructions \'el\'ementaires. La complexit\'e temporelle de la boucle de l'algorithme-retour est ainsi en $\BigO(S+k)$.
 
 Par ailleurs, l'initialisation du tableau $A$ est en $\Theta(k)$. Ce tableau $A$ est la seule addition en termes de m\'emoire par rapport \`a l'algorithme de base et il occupe autant de cases m\'emoire que le tableau $V$. 
 De ces faits, les compl\'exit\'es temporelle et spatiale de l'algorithme-retour sont respectivement en $\BigO(S+k)$ et $\Theta(S\cdot k)$.
 
\end{enumerate}

\subsection*{Question 6}
 On constate que, pour l'algorithme global, ce sont les complexit\'es de l'algorithme initial qui l'emportent, d'o\`u celles du premier algorithme sont retenues, \`a savoir des complexit\'es en $\Theta(S\cdot k)$.
 
 Cependant, il est important de remarquer que cette complexit\'e d\'epend de la valeur de $S$ et non pas de sa taille de codage, en l'occurrence $\lfloor \log_2(S)\rfloor + 1$.
 De ce fait, on dit que cet algorithme est pseudo-polynomial : il est exponentiel en la longueur de ses param\`etres, mais polynomial en leur valeur num\'erique.

\newpage
\section{Algorithme III : Cas particulier et algorithme glouton}

\subsection*{Question 7}
Voici le pseudo-code de l'algorithme \texttt{AlgoGlouton} :

\begin{algorithm}
\caption{AlgoGlouton}
\begin{algorithmic}[1]
\Require $k \geq 1$ \AND $S \geq 0$
\Function{Main}{$k$: integer, $V$: $k$-integer array, $S$: integer}
	\State $A$: integer array filled with $k$ zeros
    \State $s, i, n$: integers
    \State $s \gets S$
    \State $i \gets k$
    \State $n \gets 0$
    \While{$s \neq 0$}
    	\State $A[i] \gets s \div V[i] $
        \State $s \gets s \bmod V[i] $
        \State $n \gets n+A[i]$
        \State $i \gets i-1$
    \EndWhile
    \State \Return $(n, A)$
\EndFunction
\end{algorithmic}
\end{algorithm}

L'algorithme \texttt{AlgoGlouton} consiste en un boucle comportant deux divisions euclidiennes, une addition et une soustraction. 
Pour le calcul de la complexit\'e temporelle, consid\'erons seulement las divisions euclidiennes.
La complexit\'e de la $j$-i\`eme it\'eration est donn\'ee par

\begin{equation*}
T(j) = 
\begin{cases}
(\lfloor \log_2(\max(S, V[k])) \rfloor + 1)^2 & \text{si } j = 1 \\
(\lfloor \log_2(V[k-j+1]) \rfloor + 1)^2 & \text{sinon}
\end{cases}
\end{equation*}

Dans le pire des cas, on effectue $k$ it\'erations, d'o\`u la complexit\'e temporelle est donn\'ee par
\begin{alignat*}{1}
 \sum_{j=1}^{k} T[j] &= (\lfloor \log_2(\max(S, V[k])) \rfloor + 1)^2 + \sum_{j=2}^{k} (\lfloor \log_2(V[k-j+1]) \rfloor + 1)^2 \\
                    &= (\lfloor \log_2(\max(S, V[k])) \rfloor + 1)^2 + \sum_{l=1}^{k-1} (\lfloor \log_2(V[l]) \rfloor + 1)^2 \\
                    &\leq \left[\lfloor \log_2(\max(S, V[k])) \rfloor + 1 + \sum_{l=1}^{k-1} (\lfloor \log_2(V[l]) \rfloor + 1)\right]^2 \\
                    &\leq \left[\log_2(S) + \sum_{l=1}^{k} (\log_2(V[l]) + 1)\right]^2
\end{alignat*}

\'Etant donn\'e que les bocaux sont de capacit\'e finie, on peut bien assumer qu'il existe une constante positive $A$ qui est une borne sup\'erieure de toutes les tailles de codage des capacit\'es du syst\`eme $V$.

Il en r\'esulte que
\begin{alignat*}{1}
 \sum_{j=1}^{k} T[j] &\leq \left[\log_2(S) + A\cdot k\right]^2
\end{alignat*}

De ce fait, la complexit\'e temporelle de l'algorithme \texttt{AlgoGlouton} dans le pire des cas est en $\BigO((\log(S) + k)^2)$. On remarque que cet algorithme est bien polynomial en la longueur de ses entr\'ees.

\subsection*{Question 8}
 On dit qu'un syst\`eme de capacit\'es est {\bfseries glouton-compatible} si, pour ce syst\`eme de capacit\'es, l'algorithme \texttt{AlgoGlouton} produit la solution optimale quelle que soit soit la quantit\'e totale $S$.
 Montrons qu'il existe des syst\`emes de capacit\'es qui ne sont pas glouton-compatibles.
 
 \subsubsection*{Preuve}
 Il suffit de donner un exemple de syst\`eme de capacit\'es $V$ tel qu'il y a au moins une quantit\'e totale $S$ pour laquelle l'algorithme \texttt{AlgoGlouton} ne renvoie pas la solution optimale.
 
 Soit le syst\`eme de capacit\'es $V = [1, 4, 5]$. Soit $S = 28$ la quantit\'e totale de confiture. L'algorithme \texttt{AlgoGlouton} produit la solution $(8, [3, 0, 5])$, alors que la solution optimale est $(6, [0, 2, 4])$, puisque 5 bocaux ne suffisent pas. Ceci est donc un contre-exemple cherch\'e. \hfill\ensuremath{\square}

\subsection*{Question 9}
 Montrons que, pour tout entier $d \geq 2$, le syst\`eme de $k$ capacit\'es {\bfseries Expo} est glouton-compatible.
 
 Soit $g=(g_1, \dotsc, g_k)$ la solution produite par l'algorithme \texttt{AlgoGlouton} pour le syst\`eme {\bfseries Expo}. Supposons qu'il existe une solution optimale $o = (o_1, \dotsc, o_k)$ diff\'erente de $g$.

\begin{enumerate}[a)]
 \item Montrons qu'il existe un plus grand indice $j$ pris dans $\{1,\dotsc,k\}$ tel que $o_j < g_j$.
 
 \subsubsection*{Preuve}
 D'apr\`es les conditions du probl\`eme, on sait que les solutions $g$ et $o$ sont diff\'erentes. Donc, il existe {\itshape au moins} un indice $j \in \{1,\dotsc,k\}$ tel que $o_j < g_j$, car sinon la solution $g$ n'utiliserait toute la quantit\'e de confiture. Par ailleurs, on sait que $k$ est fini, d'o\`u il existe un plus grand indice $j \in \{1,\dotsc,k\}$ remplissant ladite condition. \hfill\ensuremath{\square}
 
 \item Montrons que \( \displaystyle\sum_{i=1}^{j} V[i]\cdot g_i = \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i\)
 
 \subsubsection*{Preuve}
 D'apr\'es la question pr\'ec\'edente, on a $o_l \geq g_l$ pour tout $l$ dans $\{j+1,\dotsc, k\}$. De plus, puisque au cours de l'algorithme glouton on choisit le nombre maximum possible de bocaux de capacit\'e $V[l]$, on a $o_l \leq g_l$. On en d\'eduit que $o_l = g_l$.
 
 Donc, on a
 \begin{alignat}{1}
    \displaystyle\sum_{i=1}^{k} V[i]\cdot g_i &= \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i \label{eq:somme_9b1} \\
    \displaystyle\sum_{i=j+1}^{k} V[i]\cdot g_i &= \displaystyle\sum_{i=j+1}^{k} V[i]\cdot o_i \label{eq:somme_9b2}
 \end{alignat}
 
 En soustrayant \eqref{eq:somme_9b2} de \eqref{eq:somme_9b1}, on obtient \( \displaystyle\sum_{i=1}^{j} V[i]\cdot g_i = \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i\) \hfill\ensuremath{\square}
 
 \item Montrons que \( \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i \geq V[j]\)
 
 \subsubsection*{Preuve}
 On sait que 
 \begin{equation*}
    \displaystyle\sum_{i=1}^{j-1} V[i]\cdot g_i \geq 0
 \end{equation*}

 En utilisant le r\'esultat de la question pr\'ec\'edente, il en r\'esulte que
 \begin{equation*}
    V[j]\cdot g_j \leq \displaystyle\sum_{i=1}^{j} V[i]\cdot o_i
 \end{equation*}
 
 D'o\`u, 
 \begin{equation*}
    V[j]\cdot (g_j - o_j) \leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i 
 \end{equation*}
 Or $g_j - o_j \geq 1$ d'apr\`es la question a) et le fait que ce sont des entiers naturels.
 Donc, \( V[j] \leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i\) \hfill\ensuremath{\square}
 
 Cette propri\'et\'e pr\'ecise l'une des mani\`eres d'utiliser le moins possible de bocaux pour remplir une quantit\'e de confiture donn\'ee. En effet, elle consiste \`a remplir au complet tous les bocaux des plus grandes capacit\'es possibles jusqu'\`a l'arriv\'ee \`a une certaine capacit\'e. Pour cette derni\`ere, on pr\'ef\`ere ne pas remplir tous les bocaux possibles, mais de se servir plut\^ot de ceux de capacit\'e plus petite. 
 
 \item Supposons que $o_i \leq d-1$ pour tout $i \in \{1,\dotsc,j-1\}$. D'apr\`es la question pr\'ec\'edente, on a 
 \begin{alignat*}{2}
 	V[j] &\leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot o_i \\
 		 &\leq \displaystyle\sum_{i=1}^{j-1} V[i]\cdot (d-1) \\
 		 &\leq (d-1)\cdot \displaystyle\sum_{i=1}^{j-1} 2^{i-1} \\
 		 &\leq (d-1)\cdot \frac{d^{j-1}-1}{d-1} \\
 	d^{j-1}	 &\leq d^{j-1}-1 & \text{car } d-1 \geq 1
 \end{alignat*}
 On arrive donc \`a une contradiction, i.e.\ il existe un indice \(l \in \{1,\dotsc,j-1\}\) tel que $o_l \geq d$. \hfill\ensuremath{\square}
 
 \item Posons la suite $o'$ telle que $o_{l}' = o_l-d, o_{l+1}' = o_{l+1}+1$ et $o_i' = o_i$ pour tout $i \neq l$ et $i \neq l+1$. Montrons que $o'$ est une solution du probl\`eme.
 
 \subsubsection*{Preuve}
 D'apr\`es les conditions du probl\`eme, on a
 \begin{equation*}
    V[l]\cdot d = V[l+1]
 \end{equation*}
 
 D'o\`u, 
 \begin{equation*}
    0 = -V[l]\cdot d + V[l+1]
 \end{equation*}
 
 Donc, 
 \begin{equation*}
    V[l]\cdot o_l + V[l+1]\cdot o_{l+1} = V[l]\cdot (o_l-d) + V[l+1]\cdot (o_{l+1} + 1),
 \end{equation*}
 i.e.\ 
 \begin{equation*}
    V[l]\cdot o_l + V[l+1]\cdot o_{l+1} = V[l]\cdot o_l' + V[l+1]\cdot o_{l+1}'
 \end{equation*}
  
  Par ailleurs, on a $o_i = o_i' $ pour tout $i \in \{1, \dotsc, k\}\setminus \{ l,l+1 \}$. 
  
  De ces faits, 
  \begin{equation*}
   \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i = \displaystyle\sum_{i=1}^{k} V[i]\cdot o_i',
  \end{equation*}
  i.e.\ $o'$ est aussi une solution du probl\`eme. \hfill\ensuremath{\square}
  
  \medskip
  On remarque que la diff\'erence entre $o'$ et $o$ est que la premi\`ere remplace $d$ bocaux d'une certaine capacit\'e dans la deuxi\`eme solution par un bocal de la capacit\'e imm\'ediatement sup\'erieure. Autrement dit, la solution $o'$ utilise $d-1$ bocaux de moins que la solution $o$.
  
  De ce fait, la solution $o$ n'est pas optimale, ce qui contredit l'hypoth\`ese de d\'epart. On en d\'eduit que, pour le syst\`eme {\bfseries Expo}, toute solution $o$ est non optimale ou elle est \'egale \`a $g$. Ceci \'equivaut \`a dire que, pour le syst\`eme {\bfseries Expo}, pour toute solution $o$, si elle est optimale alors est \'egale \`a $g$. On en d\'eduit que toute solution optimale est \'egale \`a $g$. Or il existe une solution optimale \`a ce probl\`eme. Donc, l'algorithme \texttt{AlgoGlouton} renvoie l'unique solution optimale, \`a savoir $g$, pour le syst\`eme de capacit\'es {\bfseries Expo}. \hfill\ensuremath{\square}
\end{enumerate}

\subsection*{Question 10}
 Montrons que tout syst\`eme de capacit\'es $V$ avec $k = 2$ est glouton-compatible.

 \subsubsection*{Preuve}
 On a montr\'e dans la question pr\'ec\'edente que le syst\`eme {\bfseries Expo} est glouton-compatible.

 Soit $V = [1, p]$, o\`u $p > 1$, un syst\`eme de capacit\'es quelconque. On remarque que ce syst\`eme est un syst\`eme {\bfseries Expo} avec $k = 2$ et $d = p \geq 2$.

 De ces faits, tout syst\`eme de capacit\'e $V$ de longueur $k = 2$ est bien glouton-compatible. \hfill\ensuremath{\square}
 
 \subsection*{Question 11}
 Montrons que la complexit\'e de l'algorithme \texttt{TestGloutonCompatible}$(k, V)$ est en $\BigO(k^3)$, i.e.\ qu'il est polynomial.

 \subsubsection*{Preuve}
 Le nombre d'it\'erations de la boucle externe est  
 \begin{equation*}
    \text{nbiter\_ext} = V[k-1]+V[k]-1 -(V[3]+2) +1
 \end{equation*}
 
 Or 
 \begin{align*}
 V[3]+2 &\geq 5 \\
 V[k-1]+V[k]-1 &\leq 2\cdot V[k] - 2 
\end{align*}
 
 De ces faits, 
 \begin{equation*}
    \text{nbiter\_ext} \leq 2\cdot V[k] - 6,
 \end{equation*}
 i.e.\ le nombre d'it\'erations de la boucle externe est en $\Theta(V[k])$.
 
 Par ailleurs, on effectue le m\^eme nombre d'it\'erations de la boucle interne pour chaque tour de la boucle externe, en l'occurrence $k$. De plus, chaque tour de la boucle interne comporte un premier test de v\'erit\'e entre deux nombres obtenus en $\Theta(1)$, en l'occurrence $V[j]$ et $S$, et un deuxi\`eme test sur deux nombres obtenus chacun au moyen d'un appel \`a \texttt{AlgoGlouton}. 
 D'apr\`es la question 7, sa complexit\`e est en $\BigO((\log(S) + k)^2)$. 
 Or 
 \begin{equation*}
  S \leq 2\cdot V[k] - 2,
 \end{equation*}
 i.e.\ $\log(S)$ est de l'ordre de $A$, \`a savoir la borne sup\'erieure des tailles des capacit\'es de bocaux.
 Donc, chaque tour de la boucle interne est fait en $\BigO(k^2)$.
 
 De ces faits, la complexit\`e de l'algorithme \texttt{TestGloutonCompatible} est en $\BigO(k^3)$, car $V[k]$ est born\'e par $2^A$. \hfill\ensuremath{\square}
 
 \newpage
 \part{Mise en \oe uvre}
 On a impl\'ement\'e les trois algorithmes en le langage de programmation Python. Dans les deux sections suivantes, on v\'erifie exp\'erimentalement les complexit\'es temporelles th\'eoriques d\'etermin\'ees dans les sections pr\'ec\'edentes et on essaie aussi de r\'epondre \`a la question sur la mise en \oe uvre en pratique de l'algorithme glouton.

 \section{Analyse de complexit\'e exp\'erimentale}
 Pour cette section, on a consid\'er\'e le syst\`eme de capacit\'es {\bfseries Expo} pour des valeurs $d = 2, 3$ et $4$. Pour chaque syst\`eme, on a fait varier les valeurs des param\`etres $S$ et $k$. Bien \'evidemment, leur ordre de grandeur n'est pas le m\^eme pour les trois tests, comme vous pouvez vous en apercevoir ci-dessous.

 \subsection*{Question 12}
 Pour comprendre les images donn\'ees juste apr\`es, il faut pr\'eciser que les temps trouv\'es correspondent au temps CPU et non pas au temps d'ex\'ecution, et que l'on s'est arr\^et\'es d\`es que le temps de calcul m\'esur\'e d\'epasse une minute.

 \section{Utilisation de l'algorithme glouton}
 On s'int\'eresse maintenant \`a v\'erifier la faisabilit\'e pratique de l'algorithme glouton. Deux points sont importants \`a ce sujet : la fr\'equence d'apparition des syst\`emes de capacit\'es glouton-compatibles, et ses performances dans les cas contraire \`a l'\'egard de la solution optimale.
 
 Pour ce faire, on a g\'en\'er\'e des syst\`emes de capacit\'es de mani\`ere al\'eatoire. Les capacit\'es ont \'et\'e tir\'ees al\'eatoirement dans $\Iintv{2,100}$. De plus, on a fait varier la taille $k$ des syst\`emes de 3 \`a 30. Finalement, pour chacune de ces tailles, on a obtenu 20 syst\`emes distincts.

 \subsection*{Question 13}
 Pour chacun des syst\`emes obtenus, on a test\'e s'il \'etait ou pas glouton-compatible ; e cas \'ech\'eant, on l'a pris en compte pour la d\'etermination de la proportion de syst\`emes glouton-compatibles.
 
 Cette proportion a \'et\'e calcul\'e de fa\c{c}on cumul\'ee pour chacun des sous-intervalles engendr\'es. Vous retrouverez ces r\'esultats dans la figure \ref{fig:prop} ci-dessous.
 
\begin{figure}[!h]
  \centering
  \captionsetup{justification=centering}
  \begin{tikzpicture}
	\begin{axis}[%
	  width=14cm,
	  grid=major,
	  grid style={dashed,gray!30},
	  xmin=2,
	  xmax=30,
	  xlabel={Longueur maximale ($k$)},
	  ylabel={Proportion de syst\`emes glouton-compatibles},
	  scaled x ticks = true]
	  \addplot [color=blue,solid,line width=1.0pt] table[col sep=space] 
	  {../data/proportion.txt};
	\end{axis}
  \end{tikzpicture}
  \caption[Variation de la proportion de syst\`emes glouton-compatibles]{Variation de la proportion de syst\`emes glouton-compatibles en fonction de la borne sup\'erieure de l'intervalle de longueurs consid\'er\'e}
  \label{fig:prop}
\end{figure}

On d\'eduit de cette courbe que les syst\`emes de capacit\'es glouton-compatibles sont plus rares au fur et a mesure que l'on consid\`ere des tailles plus grandes. En effet, pour l'intervalle $\Iintv{3,30}$, on compte seulement 1,07 \% de syst\`emes glouton-compatibles. Ceci veut dire qu'il y en a tr\`es peu qui sont non {\bfseries Expo}, pour lesquels l'algorithme glouton est optimal et tr\`es efficace.

 \subsection*{Question 14}
 En revanche, pour la plupart des syst\`emes g\'en\'er\'es, qui n'\'etaient pas glouton-compatibles, on a cherch\'e \`a mesurer les performances de l'algorithme glouton. Ainsi, on a lanc\'e les algorithmes \texttt{AlgoGlouton} (en question) et \texttt{AlgoProgDyn} (le meilleur) sur des diverses entr\'ees et fait un r\'esum\'e des r\'esultats obtenus. Concr\`etement, on a consid\'er\'e une quantit\'e de confiture allant de 100 jusqu'\`a 1000 pour chaque syst\`eme non glouton-compatible.
 
 On a compil\'e nos r\'esultats dans le tableau \ref{tab:stats}. On a mis en rouge le nombre de bocaux parce que c'est la caract\'eristique pour laquelle l'algorithme glouton est le moins performant ; le temps CPU \'etant son point fort, on l'a mis en bleu.
 
 \begin{table}
    \begin{tabular}{|c|cc|cc|}
	\hline \multirow{3}{*}{Mesure} & \multicolumn{4}{c|}{\'Ecart} \\ 
    \cline{2-5} & \multicolumn{2}{c}{Moyen} & \multicolumn{2}{c|}{Maximum} \\ 
	\cline{2-5} &  valeur & en \% & valeur & en \% \\ 
    \hline \color{red} Nombre de bocaux & 3.167 & 51.2 & 77 & 3850 \\ 
	\hline \color{blue} Temps CPU (en \si{s}) & $\num{6.704E-03}$ & $\num{1.716E+05}$ & $\num{4.218E-02}$ & $\num{1.6E+06}$ \\ 
	\hline
	\end{tabular}
	\caption[Performance compar\'ee de l'algorithme glouton]{Statistiques sur les performances des algorithmes glouton et par programmation dynamique}
  \label{tab:stats}
\end{table}

Comme mentionn\'e pr\'ec\'edemment, l'algorithme glouton est incontestablement le plus r\'eactif. On peut s'en convaincre notamment avec la deuxi\`eme mesure du tableau ci-dessus. De plus, il semblerait que l'algorithme glouton n'est pas du tout mauvais si on ne regardait que les \'ecarts moyen et maximum du nombre de bocaux en valeur. 

Cependant, il faut rappeler que la quantit\'e maximale de confiture test\'ee a \'et\'e 1000, i.e.\ elle n'a pas \'et\'e tr\`es \'el\'ev\'ee. De ce fait on justifie que les \'ecarts en pourcentage montrent la faible efficacit\'e de cet algorithme.

 
\newpage

\part*{Conclusion}
\addcontentsline{toc}{part}{Conclusion}

\todo{\`a faire}

\newpage
\begin{appendices}
 \section{Suites croissantes}
 \label{appendix:suites}
 On rappelle la d\'efinition des suites $b(s)$ et $c(s)$ comme suit :
\begin{equation*}
\left .b(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      2 & \text{si } s = 1 \\
      2\cdot b(s-2) + 2 & \text{si } s\geq 2 
   \end{cases} \right.
   \text{ et }
\left .c(s) = \begin{cases} 
      0 & \text{si } s = 0 \\
      %2 & \text{si } s = 1 \\
      2\cdot c(s-1) + 2 & \text{si } s\geq 1 
   \end{cases} \right.
\end{equation*}

Montrons que les deux suites sont croissantes.

\subsection*{Suite $b(s)$}
Soit la propri\'et\'e suivante $Q_{1}(s), s \geq 0$ : $b(s) \leq b(s+1)$.
Montrons-la par r\'ecurrence d'ordre 2 sur $s$

\subsubsection*{Preuve}
\underline{Base} : On a $b(0) = 0 \leq 2 = b(1) \leq 2\cdot 0 + 2 = b(2)$. 
Donc, la propri\'et\'e est v\'erifi\'ee aux rangs 0 et 1.

\medskip
\underline{Induction} : Supposons $Q_{1}(s-2)$ et $Q_{1}(s-1)$ vraies pour un $s \geq 2$ fix\'e. 
Montrons $Q_{1}(s)$ vraie.

\smallskip
Par hypoth\`ese de r\'ecurrence,
\begin{equation*}
   b(s-2) \leq b(s-1)
\end{equation*}

D'o\`u, 
\begin{equation}
   2\cdot b(s-2)+2 \leq 2\cdot b(s-1)+2 \label{eq:ineg_a1}
\end{equation}

Or, par d\'efinition, 
\begin{equation}
   b(s+1) = 2\cdot b(s-1) + 2 \label{eq:def_a1}
\end{equation}

En rempla\c{c}ant \eqref{eq:def_a1} en \eqref{eq:ineg_a1}, on obtient $b(s) \leq b(s+1)$, i.e.\ la propri\'et\'e est v\'erifi\'ee au rang $s$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{1}(0) \text{ et } Q_{1}(1) \text{ vraies } \\
\forall s \geq 2, [(Q_{1}(s-2) \text{ et } Q_{1}(s-1)) \Rightarrow Q_{1}(s) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, b(s) \leq b(s+1)
\end{array}\right .
\end{equation*}

\bigskip
On remarque que ceci correspond \`a la d\'efinition d'une suite croissante. \hfill\ensuremath{\square}

\subsection*{Suite $c(s)$}
Soit la propri\'et\'e suivante $Q_{2}(s), s \geq 0$ : $c(s) \geq 0$.
Montrons-la par r\'ecurrence faible sur $s$.

\subsubsection*{Preuve}
\underline{Base} : Pour $s = 0$, on a $c(0) = 0 \geq 0$. 
Donc, la propri\'et\'e est v\'erifi\'e aux rang 0.

\medskip
\underline{Induction} : Supposons $Q_{2}(s)$ vraie pour un $s \geq 0$ fix\'e. 
Montrons $Q_{2}(s+1)$ vraie.

\smallskip
Par d\'efinition,
\begin{equation}
   c(s+1) = 2\cdot c(s) + 2 \label{eq:def_a2}
\end{equation}

Or, par hypoth\`ese de r\'ecurrence,
\begin{equation*}
   c(s) \geq 0
\end{equation*}

D'o\`u, 
\begin{equation}
   2\cdot c(s)+2 \geq 2 \label{eq:ineg_a2}
\end{equation}

En rempla\c{c}ant \eqref{eq:def_a2} en \eqref{eq:ineg_a2}, il r\'esulte que $c(s+1) \geq 2$. On en d\'eduit par transitivit\'e que la propri\'et\'e est v\'erifi\'ee au rang $s+1$.

\medskip
\underline{Conclusion} : 
\begin{equation*}
\left .\begin{array}{l}
Q_{2}(0) \text{ vraie } \\
\forall s \geq 0, [Q_{2}(s) \Rightarrow Q_{2}(s+1) ]
\end{array} \right \}
\left .\begin{array}{l}
\forall s \in \mathbb{N}, c(s) \geq 0
\end{array}\right .
\end{equation*}

\bigskip
Par ailleurs, on a 
\begin{equation*}
   c(s) = 2\cdot c(s-1) + 2, s \geq 1
\end{equation*}

D'o\`u,
\begin{equation}
   c(s) \geq 2\cdot c(s-1) \label{eq:ineg_a3}
\end{equation}

Comme cette suite est positive, on sait que 
\begin{equation}
   2\cdot c(s-1) \geq c(s-1) \label{eq:ineg_a4}
\end{equation}

Donc, par transitivit\'e entre \eqref{eq:ineg_a3} et \eqref{eq:ineg_a4}, $c(s) \geq c(s-1)$.

Autrement dit, pour tout $s \geq 0$, $c(s+1) \geq c(s)$. \hfill\ensuremath{\square}

\newpage
\section{Complexit\'e de \texttt{RechercheExhaustive} dans le cas g\'en\'eral}
\label{appendix:rech_gen}
\todo{\`a faire}

\end{appendices}
	
\printindex
\end{document}



